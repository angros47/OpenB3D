<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
	<meta name="author" content="Angelo "/>
	<meta name="created" content="2020-01-06T16:35:06"/>
	<meta name="changedby" content="Angelo"/>
	<meta name="changed" content="2025-03-20T00:59:31.262570020"/>
	<style type="text/css">
		@page { size: 21cm 29.7cm; margin: 2cm }
		p { margin-bottom: 0.21cm; background: transparent }
		pre { background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "Noto Sans Mono CJK SC", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
		td p { background: transparent }
		em { font-style: italic }
		a:link { color: #000080; so-language: zxx; text-decoration: underline }
		strong { font-weight: bold }
		a:visited { color: #800000; so-language: zxx; text-decoration: underline }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr">
<div id="Section2" dir="ltr"><p align="center" style="margin-bottom: 0cm">
	<span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">OpenB3d
	1.</span></span></span><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">4</span></span></span><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">
	Guide</span></span></span></p>
	<p align="center" style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	(<a href="https://sourceforge.net/projects/minib3d/files/"><span style="font-variant: normal"><font size="1" style="font-size: 8pt">https://sourceforge.net/projects/minib3d/files/</font></span></a>
	)</p>
</div>
<div id="Section1" dir="ltr" gutter="0" style="column-count: 2"><p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Global</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AmbientLight"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AmbientLight</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AmbientShader"><span style="font-variant: small-caps">AmbientShader</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AntiAlias"><span style="font-variant: small-caps">AntiAlias</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ClearWorld"><span style="font-variant: small-caps">ClearWorld</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#Graphics3D"><span style="font-variant: small-caps">Graphics3D</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RenderWorld"><span style="font-variant: small-caps">RenderWorld</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UpdateWorld"><span style="font-variant: small-caps">UpdateWorld</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#Wireframe"><span style="font-variant: small-caps">Wireframe</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Texture</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateTexture"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateTexture</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadAnimTexture"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadAnimTexture</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadTexture"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadTexture</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadMaterial"><span style="font-variant: small-caps">LoadMaterial</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetBrushTexture"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">GetBrushTexture</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BackBufferToTex"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">BackBufferToTex</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BufferToTex"><span style="font-variant: small-caps">BufferToTex</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TexToBuffer"><span style="font-variant: small-caps">TexToBuffer</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraToTex"><span style="font-variant: small-caps">CameraToTex</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#DepthBufferToTex"><span style="font-variant: small-caps">DepthBufferToTex</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureFilter"><span style="font-variant: small-caps">TextureFilter</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ClearTextureFilters"><span style="font-variant: small-caps">ClearTextureFilters</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PositionTexture"><span style="font-variant: small-caps">PositionTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RotateTexture"><span style="font-variant: small-caps">RotateTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ScaleTexture"><span style="font-variant: small-caps">ScaleTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureHeight"><span style="font-variant: small-caps">TextureHeight</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureWidth"><span style="font-variant: small-caps">TextureWidth</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureName"><span style="font-variant: small-caps">TextureName</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeTexture"><span style="font-variant: small-caps">FreeTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureBlend"><span style="font-variant: small-caps">TextureBlend</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TextureCoords"><span style="font-variant: small-caps">TextureCoords</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetCubeFace"><span style="font-variant: small-caps">SetCubeFace</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetCubeMode"><span style="font-variant: small-caps">SetCubeMode</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Brush</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateBrush"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateBrush</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadBrush"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadBrush</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushAlpha"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">BrushAlpha</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushBlend"><span style="font-variant: small-caps">BrushBlend</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushColor"><span style="font-variant: small-caps">BrushColor</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushFX"><span style="font-variant: small-caps">BrushFX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushShininess"><span style="font-variant: small-caps">BrushShininess</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#BrushTexture"><span style="font-variant: small-caps">BrushTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetEntityBrush"><span style="font-variant: small-caps">GetEntityBrush</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetSurfaceBrush"><span style="font-variant: small-caps">GetSurfaceBrush</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeBrush"><span style="font-variant: small-caps">FreeBrush</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Shader</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateShader"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateShader</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateShaderVGF"><span style="font-variant: small-caps">CreateShaderVGF</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadShader"><span style="font-variant: small-caps">LoadShader</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadShaderVGF"><span style="font-variant: small-caps">LoadShaderVGF</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeShader"><span style="font-variant: small-caps">F</span><span style="font-variant: small-caps">reeShader</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetShaderProgram"><span style="font-variant: small-caps">GetShaderProgram</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetFloat"><span style="font-variant: small-caps">SetFloat</span></a><span style="font-variant: small-caps">,
	</span><a href="#SetFloat2"><span style="font-variant: small-caps">SetFloat2</span></a><span style="font-variant: small-caps">,
	</span><a href="#SetFloat3"><span style="font-variant: small-caps">SetFloat3</span></a><span style="font-variant: small-caps">,
	</span><a href="#SetFloat4"><span style="font-variant: small-caps">SetFloat4</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetInteger"><span style="font-variant: small-caps">SetInteger</span></a><span style="font-variant: small-caps">,
	</span><span style="font-variant: small-caps"><a href="#SetInteger2">SetInteger2</a>,
	<a href="#SetInteger3">SetInteger3</a></span><span style="font-variant: small-caps">,
	</span><a href="#SetInteger4"><span style="font-variant: small-caps">SetInteger4</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseFloat"><span style="font-variant: small-caps">UseFloat</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseFloat2"><span style="font-variant: small-caps">UseFloat2</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseFloat3"><span style="font-variant: small-caps">UseFloat3</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseFloat4"><span style="font-variant: small-caps">UseFloat4</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseInteger"><span style="font-variant: small-caps">UseInteger</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseInteger2"><span style="font-variant: small-caps">UseInteger2</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseInteger3"><span style="font-variant: small-caps">UseInteger3</span></a><span style="font-variant: small-caps">,
	</span><a href="#UseInteger4"><span style="font-variant: small-caps">UseInteger4</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseEntity"><span style="font-variant: small-caps">UseEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseMatrix"><span style="font-variant: small-caps">UseMatrix</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseSurface"><span style="font-variant: small-caps">UseSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShadeEntity"><span style="font-variant: small-caps">ShadeEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShadeMesh"><span style="font-variant: small-caps">ShadeMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShaderFunction"><span style="font-variant: small-caps">ShaderFunction</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShaderMaterial"><span style="font-variant: small-caps">ShaderMaterial</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShaderTexture"><span style="font-variant: small-caps">ShaderTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShadeSurface"><span style="font-variant: small-caps">ShadeSurface</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Mesh</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadAnimMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadAnimMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CopyMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CopyMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RepeatMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">RepeatMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateCone"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateCone</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateCube"><span style="font-variant: small-caps">CreateCube</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateCylinder"><span style="font-variant: small-caps">CreateCylinder</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateSphere"><span style="font-variant: small-caps">CreateSphere</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateQuad"><span style="font-variant: small-caps">CreateQuad</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PaintMesh"><span style="font-variant: small-caps">PaintMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AddMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AddMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PositionMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PositionMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RotateMesh"><span style="font-variant: small-caps">RotateMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ScaleMesh"><span style="font-variant: small-caps">ScaleMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshCSG"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">MeshCSG</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshCullRadius"><span style="font-variant: small-caps">MeshCullRadius</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountBones"><span style="font-variant: small-caps">C</span><span style="font-variant: small-caps">ountBones</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountSurfaces"><span style="font-variant: small-caps">CountSurfaces</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SkinMesh"><span style="font-variant: small-caps">SkinMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FitMesh"><span style="font-variant: small-caps">FitMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FlipMesh"><span style="font-variant: small-caps">FlipMesh</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UpdateNormals"><span style="font-variant: small-caps">UpdateNormals</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UpdateTexCoords"><span style="font-variant: small-caps">UpdateTexCoords</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshesIntersect"><span style="font-variant: small-caps">MeshesIntersect</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshDepth"><span style="font-variant: small-caps">MeshDepth</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshHeight"><span style="font-variant: small-caps">MeshHeight</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MeshWidth"><span style="font-variant: small-caps">MeshWidth</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetSurface"><span style="font-variant: small-caps">GetSurface</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	<br/>

	</p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Bone</p>
	<p style="font-variant: small-caps; font-weight: normal; margin-left: 1.25cm; margin-bottom: 0cm">
	<font color="#000080"><u><a href="#CreateBone">CreateBone</a></u></font></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-left: 1.25cm; margin-bottom: 0cm">
	<font color="#000080"><u><a href="#GetBone">GetBone</a></u></font></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-left: 1.25cm; margin-bottom: 0cm">
	<font color="#000080"><u><a href="#MoveBone">MoveBone</a></u></font></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-left: 1.25cm; margin-bottom: 0cm">
	<font color="#000080"><u><a href="#PositionBone">PositionBone</a></u></font></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-left: 1.25cm; margin-bottom: 0cm">
	<font color="#000080"><u><a href="#RotateBone">RotateBone</a></u></font></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Surface</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateSurface"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateSurface</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AddTriangle"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AddTriangle</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AddVertex"><span style="font-variant: small-caps">AddVertex</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TriangleVertex"><span style="font-variant: small-caps">TriangleVertex</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountTriangles"><span style="font-variant: small-caps">CountTriangles</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountVertices"><span style="font-variant: small-caps">CountVertices</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PaintSurface"><span style="font-variant: small-caps">PaintSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ClearSurface"><span style="font-variant: small-caps">ClearSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FindSurface"><span style="font-variant: small-caps">FindSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexAlpha"><span style="font-variant: small-caps">VertexAlpha</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexColor"><span style="font-variant: small-caps">VertexColor</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexRed"><span style="font-variant: small-caps">VertexRed</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexBlue"><span style="font-variant: small-caps">VertexBlue</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexGreen"><span style="font-variant: small-caps">VertexGreen</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexNormal"><span style="font-variant: small-caps">VertexNormal</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexNX"><span style="font-variant: small-caps">VertexNX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexNY"><span style="font-variant: small-caps">VertexNY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexNZ"><span style="font-variant: small-caps">VertexNZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexCoords"><span style="font-variant: small-caps">VertexCoords</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexX"><span style="font-variant: small-caps">VertexX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexY"><span style="font-variant: small-caps">VertexY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexZ"><span style="font-variant: small-caps">VertexZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexTexCoords"><span style="font-variant: small-caps">VertexTexCoords</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexU"><span style="font-variant: small-caps">VertexU</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexV"><span style="font-variant: small-caps">VertexV</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VertexW"><span style="font-variant: small-caps">VertexW</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Camera</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateCamera"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateCamera</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraClsColor"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CameraClsColor</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraClsMode"><span style="font-variant: small-caps">CameraClsMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraFogColor"><span style="font-variant: small-caps">CameraFogColor</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraFogMode"><span style="font-variant: small-caps">CameraFogMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraFogRange"><span style="font-variant: small-caps">CameraFogRange</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraPick"><span style="font-variant: small-caps">CameraPick</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraProject"><span style="font-variant: small-caps">CameraProject</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ProjectedX"><span style="font-variant: small-caps">ProjectedX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ProjectedY"><span style="font-variant: small-caps">ProjectedY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ProjectedZ"><span style="font-variant: small-caps">ProjectedZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraProjMatrix"><span style="font-variant: small-caps">CameraProjMatrix</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraProjMode"><span style="font-variant: small-caps">CameraProjMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraRange"><span style="font-variant: small-caps">CameraRange</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraViewport"><span style="font-variant: small-caps">CameraViewport</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CameraZoom"><span style="font-variant: small-caps">CameraZoom</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityInView"><span style="font-variant: small-caps">EntityInView</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedEntity"><span style="font-variant: small-caps">PickedEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedSurface"><span style="font-variant: small-caps">PickedSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedTriangle"><span style="font-variant: small-caps">PickedTriangle</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedX"><span style="font-variant: small-caps">PickedX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedY"><span style="font-variant: small-caps">PickedY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedZ"><span style="font-variant: small-caps">PickedZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedNX"><span style="font-variant: small-caps">PickedNX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedNY"><span style="font-variant: small-caps">PickedNY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedNZ"><span style="font-variant: small-caps">PickedNZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PickedTime"><span style="font-variant: small-caps">PickedTime</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Light</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateLight"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateLight</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LightColor"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LightColor</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LightConeAngles"><span style="font-variant: small-caps">LightConeAngles</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LightRange"><span style="font-variant: small-caps">LightRange</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Pivot</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreatePivot"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreatePivot</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Sprite</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateSprite"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateSprite</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateVoxelSprite"><span style="font-variant: small-caps">CreateVoxelSprite</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadSprite"><span style="font-variant: small-caps">LoadSprite</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#HandleSprite"><span style="font-variant: small-caps">HandleSprite</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RotateSprite"><span style="font-variant: small-caps">RotateSprite</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ScaleSprite"><span style="font-variant: small-caps">ScaleSprite</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SpriteRenderMode"><span style="font-variant: small-caps">SpriteRenderMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SpriteViewMode"><span style="font-variant: small-caps">SpriteViewMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VoxelSpriteMaterial"><span style="font-variant: small-caps">VoxelSpriteMaterial</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Shadow</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateShadow"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateShadow</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeShadow"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">FreeShadow</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ResetShadow"><span style="font-variant: small-caps">ResetShadow</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Plane</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreatePlane"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreatePlane</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Terrain</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateTerrain"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateTerrain</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateGeosphere"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateGeosphere</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadTerrain"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadTerrain</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadGeosphere"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">LoadGeosphere</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GeosphereHeight"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">GeosphereHeight</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ModifyTerrain"><span style="font-variant: small-caps">ModifyTerrain</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ModifyGeosphere"><span style="font-variant: small-caps">ModifyGeosphere</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TerrainHeight"><span style="font-variant: small-caps">TerrainHeight</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TerrainX"><span style="font-variant: small-caps">TerrainX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TerrainY"><span style="font-variant: small-caps">TerrainY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TerrainZ"><span style="font-variant: small-caps">TerrainZ</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	fluid</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateFluid"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateFluid</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateBlob"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateBlob</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FluidArray"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">FluidArray</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FluidFunction"><span style="font-variant: small-caps">FluidFunction</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FluidThreshold"><span style="font-variant: small-caps">FluidThreshold</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Octree</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateOcTree"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateOcTree</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#OctreeBlock"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">OctreeBlock</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#OctreeMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">OctreeMesh</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Particle System</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateParticleEmitter"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateParticleEmitter</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterParticleFunction"><span style="font-variant: small-caps">EmitterParticleFunction</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterParticleLife"><span style="font-variant: small-caps">EmitterParticleLife</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterParticleSpeed"><span style="font-variant: small-caps">EmitterParticleSpeed</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterRate"><span style="font-variant: small-caps">EmitterRate</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterVariance"><span style="font-variant: small-caps">EmitterVariance</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EmitterVector"><span style="font-variant: small-caps">EmitterVector</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ParticleColor"><span style="font-variant: small-caps">ParticleColor</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ParticleTrail"><span style="font-variant: small-caps">ParticleTrail</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ParticleVector"><span style="font-variant: small-caps">ParticleVector</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Entity Movement</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#MoveEntity"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">MoveEntity</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PointEntity"><span style="font-variant: small-caps">PointEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PositionEntity"><span style="font-variant: small-caps">PositionEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TranslateEntity"><span style="font-variant: small-caps">TranslateEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#RotateEntity"><span style="font-variant: small-caps">RotateEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TurnEntity"><span style="font-variant: small-caps">TurnEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ScaleEntity"><span style="font-variant: small-caps">ScaleEntity</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Entity Animation</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AddAnimSeq"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AddAnimSeq</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LoadAnimSeq"><span style="font-variant: small-caps">LoadAnimSeq</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AnimSeq"><span style="font-variant: small-caps">AnimSeq</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#Animate"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">Animate</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AnimLength"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AnimLength</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AnimTime"><span style="font-variant: small-caps">AnimTime</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#Animating"><span style="font-variant: small-caps">Animating</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetAnimKey"><span style="font-variant: small-caps">SetAnimKey</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#SetAnimTime"><span style="font-variant: small-caps">SetAnimTime</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ExtractAnimSeq"><span style="font-variant: small-caps">ExtractAnimSeq</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Entity Control</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeEntity"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">FreeEntity</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CopyEntity"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CopyEntity</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityAlpha"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityAlpha</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityColor"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityColor</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityShininess"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityShininess</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityTexture"><span style="font-variant: small-caps">EntityTexture</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PaintEntity"><span style="font-variant: small-caps">PaintEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityFX"><span style="font-variant: small-caps">EntityFX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityAutoFade"><span style="font-variant: small-caps">EntityAutoFade</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityBlend"><span style="font-variant: small-caps">EntityBlend</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityOrder"><span style="font-variant: small-caps">EntityOrder</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#NameEntity"><span style="font-variant: small-caps">NameEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#HideEntity"><span style="font-variant: small-caps">HideEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ShowEntity"><span style="font-variant: small-caps">ShowEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityParent"><span style="font-variant: small-caps">EntityParent</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetParentEntity"><span style="font-variant: small-caps">GetParentEntity</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormNormal"><span style="font-variant: small-caps">TFormNormal</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormPoint"><span style="font-variant: small-caps">TFormPoint</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormVector"><span style="font-variant: small-caps">TFormVector</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormedX"><span style="font-variant: small-caps">TFormedX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormedY"><span style="font-variant: small-caps">TFormedY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TFormedZ"><span style="font-variant: small-caps">TFormedZ</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Entity State</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountChildren"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CountChildren</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityDistance"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityDistance</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityVisible"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityVisible</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityX"><span style="font-variant: small-caps">EntityX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityY"><span style="font-variant: small-caps">EntityY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityZ"><span style="font-variant: small-caps">EntityZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityPitch"><span style="font-variant: small-caps">EntityPitch</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityRoll"><span style="font-variant: small-caps">EntityRoll</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityYaw"><span style="font-variant: small-caps">EntityYaw</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityScaleX"><span style="font-variant: small-caps">EntityScaleX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityScaleY"><span style="font-variant: small-caps">EntityScaleY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityScaleZ"><span style="font-variant: small-caps">EntityScaleZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FindChild"><span style="font-variant: small-caps">FindChild</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetChild"><span style="font-variant: small-caps">GetChild</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#DeltaPitch"><span style="font-variant: small-caps">DeltaPitch</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#DeltaYaw"><span style="font-variant: small-caps">DeltaYaw</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityClass"><span style="font-variant: small-caps">EntityClass</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityName"><span style="font-variant: small-caps">EntityName</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityMatrix"><span style="font-variant: small-caps">EntityMatrix</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityPick"><span style="font-variant: small-caps">EntityPick</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#LinePick"><span style="font-variant: small-caps">LinePick</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Entity Collision</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityRadius"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">EntityRadius</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ResetEntity"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ResetEntity</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#Collisions"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">Collisions</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CountCollisions"><span style="font-variant: small-caps">CountCollisions</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionEntity"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CollisionEntity</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionNX"><span style="font-variant: small-caps">CollisionNX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionNY"><span style="font-variant: small-caps">CollisionNY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionNZ"><span style="font-variant: small-caps">CollisionNZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionX"><span style="font-variant: small-caps">CollisionX</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionY"><span style="font-variant: small-caps">CollisionY</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionZ"><span style="font-variant: small-caps">CollisionZ</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionSurface"><span style="font-variant: small-caps">CollisionSurface</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionTriangle"><span style="font-variant: small-caps">CollisionTriangle</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CollisionTime"><span style="font-variant: small-caps">CollisionTime</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityCollided"><span style="font-variant: small-caps">EntityCollided</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityBox"><span style="font-variant: small-caps">EntityBox</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityType"><span style="font-variant: small-caps">EntityType</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#EntityPickMode"><span style="font-variant: small-caps">EntityPickMode</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetEntityType"><span style="font-variant: small-caps">GetEntityType</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ClearCollisions"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ClearCollisions</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Actions</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActExecute"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ActExecute</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActFadeTo"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ActFadeTo</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActIterator"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">A</span></span></span><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ctIterator</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActMoveBy"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">ActMoveBy</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActNewtonian"><span style="font-variant: small-caps">ActNewtonian</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActScaleTo"><span style="font-variant: small-caps">ActScaleTo</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActStop"><span style="font-variant: small-caps">A</span><span style="font-variant: small-caps">ctStop</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActTintTo"><span style="font-variant: small-caps">ActTintTo</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActTrackByDistance"><span style="font-variant: small-caps">ActTrackByDistance</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActTrackByPoint"><span style="font-variant: small-caps">ActTrackByPoint</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActTurnBy"><span style="font-variant: small-caps">ActTurnBy</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActTurnTo"><span style="font-variant: small-caps">ActTurnTo</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActVector"><span style="font-variant: small-caps">ActVector</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#ActWait"><span style="font-variant: small-caps">A</span><span style="font-variant: small-caps">ctWait</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TriggerCloseTo"><span style="font-variant: small-caps">TriggerCloseTo</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TriggerCollision"><span style="font-variant: small-caps">TriggerCollision</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#TriggerDistance"><span style="font-variant: small-caps">TriggerDistance</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AppendAction"><span style="font-variant: small-caps">AppendAction</span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeAction"><span style="font-variant: small-caps">FreeAction</span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Physics</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateConstraint"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateConstraint</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateRigidBody"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateRigidBody</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeConstraint"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">FreeConstraint</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreeRigidBody"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">FreeRigidBody</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Stencil</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreateStencil"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreateStencil</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#UseStencil"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">UseStencil</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#StencilAlpha"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">StencilAlpha</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#StencilClsColor"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">StencilClsColor</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#StencilClsMode"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">StencilClsMode</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#StencilMesh"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">StencilMesh</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#StencilMode"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">StencilMode</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	Post Processing</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#CreatePostFX"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">CreatePostFX</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#AddRenderTarget"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">AddRenderTarget</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#FreePostFX"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">F</span></span></span><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">reePostFX</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PostFXBuffer"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PostFXBuffer</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PostFXFunction"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PostFXFunction</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PostFXShader"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PostFXShader</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PostFXShaderPass"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PostFXShaderPass</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#PostFXTexture"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">PostFXTexture</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	3D Maths</p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VectorPitch"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">VectorPitch</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#VectorYaw"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">VectorYaw</span></span></span></a></p>
	<p style="margin-left: 1.25cm; margin-bottom: 0cm"><a href="#GetMatElement"><span style="font-variant: small-caps"><span lang="en-US"><span style="font-weight: normal">GetMatElement</span></span></span></a></p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	<br/>

	</p>
	<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
	<br/>

	</p>
</div>
<p style="font-variant: small-caps; font-weight: normal; margin-bottom: 0cm">
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActExecute"></a>
<b>Action* ActExecute(void (*func)(void))</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">call the function </span><span lang="en-US"><i>func</i></span><span lang="en-US">
at the next </span><a href="#UpdateWorld">UpdateWorld</a>, and
complete immediately after<span lang="en-US">. </span>
</p>
<p style="margin-bottom: 0cm">If the action is appended to another
one with <a href="#AppendAction">AppendAction</a>, the function will
be executed only after the previous action is completed, and this
makes event-based programming possible 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActFadeTo"></a>
<b>Action* ActFadeTo(Entity* entity, float a, float rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">set the alpha level of</span><span lang="en-US">
the selected </span><span lang="en-US"><i>entity </i></span><span lang="en-US">to
</span><span lang="en-US"><i>a</i></span><span lang="en-US"><i>.</i></span><span lang="en-US">
T</span><span lang="en-US">he </span><span lang="en-US">fading </span><span lang="en-US">will
happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster </span><span lang="en-US">change</span><span lang="en-US">),
at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span>
</p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActIterator"></a>
<b>Action* ActIterator()</b></p>
<p style="margin-bottom: 0cm">Creates a special action that does
nothing, but repeats one or more actions in an infinite loop at each
<a href="#UpdateWorld">UpdateWorld</a>. All the actions that need to
be repeated can be added to the iterator action using <a href="#AppendAction">AppendAction</a>:
they must <b>not</b> be appended to each other, but have to be
appended to the iterator action. If more than one action is appended
to an iterator, they will be executed in sequence.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActMoveBy"></a>
<b>Action* ActMoveBy(Entity* entity, float x, float y, float z, float
rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will move the selected </span><span lang="en-US"><i>entity</i></span><span lang="en-US">.
It is the equivalent of MoveEntity entity, x, y, z, but the
movement will happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster movement), at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActMoveTo"></a>
<b>Action* ActMoveTo(Entity* entity, float x, float y, float z, float
rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will move the selected </span><span lang="en-US"><i>entity </i></span><span lang="en-US">to
the absolute coordinates</span><span lang="en-US"> </span><span lang="en-US"><i>x</i></span><span lang="en-US">,
</span><span lang="en-US"><i>y</i></span><span lang="en-US">, </span><span lang="en-US"><i>z.</i></span><span lang="en-US">
T</span><span lang="en-US">he movement will happen gradually, at a
given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster movement), at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span><span lang="en-US">If the entity is moved before it reaches
its destination by other command, it will keep that in account and
correct its trajectory.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActNewtonian"></a>
<b><span lang="en-US">Action* ActNewtonian(Entity* ent</span><span lang="en-US">ity</span><span lang="en-US">,
float </span><span lang="en-US">percentage</span><span lang="en-US">)</span></b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will move the selected </span><span lang="en-US"><i>entity</i></span><span lang="en-US"><span style="font-style: normal">
</span></span><span lang="en-US"><span style="font-style: normal">in
the same direction it moved the last time, simulating momentum. </span></span><span lang="en-US"><span style="font-style: normal">At
each frame, the movement will be a </span></span><span lang="en-US"><i>percentage</i></span><span lang="en-US"><span style="font-style: normal">
of the last one. Note that this action wont handle rotations or
collisions. Collisions can be handled separately, and rotations can
be achieved by applying this action to several pivots constrained
together with </span></span><a href="#CreateConstraint">CreateConstraint</a><span lang="en-US"><span style="font-style: normal">,
and then applying an entity controlled by them with </span></span><a href="#CreateRigidBody">CreateRigidBody</a><span lang="en-US"><span style="font-style: normal">.
That would allow to create a lightweight physics engine without
needing external libraries.</span></span></p>
<p style="margin-bottom: 0cm">This action is never completed, and
will continue until its stopped with <a href="#FreeAction">FreeAction</a>.</p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActScaleTo"></a>
<b>Action* ActScaleTo(Entity* entity, float x, float y, float z,
float rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">scale</span><span lang="en-US">
the selected </span><span lang="en-US"><i>entity </i></span><span lang="en-US">to
</span><span lang="en-US"><i>x</i></span><span lang="en-US">, </span><span lang="en-US"><i>y</i></span><span lang="en-US">,
</span><span lang="en-US"><i>z.</i></span><span lang="en-US"> T</span><span lang="en-US">he
</span><span lang="en-US">scaling </span><span lang="en-US">will
happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster </span><span lang="en-US">scaling</span><span lang="en-US">),
at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span>
</p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActStop"></a>
<b>Action* ActStop(Action* act2)</b></p>
<p style="margin-bottom: 0cm">Creates an action that will stop the
given action, and all actions appended to it, at the next
<a href="#UpdateWorld">UpdateWorld</a>. It is useful in particular to
stop actions like <a href="#ActTrackByDistance">ActTrackByDistance</a>,
or <a href="#ActTrackByPoint">ActTrackByPoint</a>, that never
complete on their own. 
</p>
<p style="margin-bottom: 0cm"><b>Warning</b>: this action does not
check if <i>act2</i><span style="font-style: normal"> has already
been terminated by another occurrence of ActStop, or if it has
already completed on its own: in case, the behavior is undefined and
will likely lead to a crash of the program, so there should be no
more than one occurrence of StopAction targeting the same action.
Instead, its perfectly safe to use it to stop an action that has
not started yet.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActTintTo"></a>
<b>Action* ActTintTo(Entity* entity, float r, float g, float b, float
rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">set the </span><span lang="en-US">color
</span><span lang="en-US">of</span><span lang="en-US"> the selected
</span><span lang="en-US"><i>entity </i></span><span lang="en-US">to
</span><span lang="en-US"><i>r</i></span><span lang="en-US"><span style="font-style: normal">,</span></span><span lang="en-US"><i>
g</i></span><span lang="en-US"><span style="font-style: normal">,</span></span><span lang="en-US"><i>
b</i></span><span lang="en-US"><i>.</i></span><span lang="en-US"> T</span><span lang="en-US">he
</span><span lang="en-US">change in color</span><span lang="en-US">
</span><span lang="en-US">will happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster </span><span lang="en-US">change</span><span lang="en-US">),
at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span>
</p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActTrackByDistance"></a>
<b>Action* ActTrackByDistance(Entity* entity, Entity* target, float
distance, float rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will move the selected </span><span lang="en-US"><i>entity
</i></span><span lang="en-US">to</span><span lang="en-US">ward</span><span lang="en-US">
</span><span lang="en-US"><i>target</i></span><span lang="en-US">
</span><span lang="en-US">until it is at the given </span><span lang="en-US"><i>distance</i></span><span lang="en-US">.
</span><span lang="en-US"> </span><span lang="en-US">T</span><span lang="en-US">he
movement will happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster movement), at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span><span lang="en-US">The entity will </span><span lang="en-US">always
point at the </span><span lang="en-US">target entity. </span><span lang="en-US">If
the entity is moved before it reaches its destination by other
command, it will keep that in account and correct its trajectory.
</span><span lang="en-US">This action is never completed, and will
continue until its stopped with </span><a href="#FreeAction">FreeAction</a><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActTrackByPoint"></a>
<b>Action* ActTrackByPoint(Entity* entity, Entity* target, float x,
float y, float z, float rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will move the selected </span><span lang="en-US"><i>entity </i></span><span lang="en-US">to
the coordinates</span><span lang="en-US"> </span><span lang="en-US"><i>x</i></span><span lang="en-US">,
</span><span lang="en-US"><i>y</i></span><span lang="en-US">, </span><span lang="en-US"><i>z
</i></span><span lang="en-US">related to </span><span lang="en-US"><i>target</i></span><span lang="en-US">.
</span><span lang="en-US">T</span><span lang="en-US">he movement will
happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster movement), at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span><span lang="en-US">The entity will also attempt to turn at the
same direction that the target entity is oriented. </span><span lang="en-US">If
the entity is moved before it reaches its destination by other
command, it will keep that in account and correct its trajectory.
</span><span lang="en-US">This action is never completed, and will
continue until its stopped with </span><a href="#FreeAction">FreeAction</a><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActTurnBy"></a>
<b>Action* ActTurnBy(Entity* entity, float x, float y, float z, float
rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will turn the selected </span><span lang="en-US"><i>entity</i></span><span lang="en-US">.
It is the equivalent of TurnEntity entity, x, y, z, but the
movement will happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster movement), at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActTurnTo"></a>
<b>Action* ActTurnTo(Entity* entity, float x, float y, float z, float
rate)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">turn </span><span lang="en-US">the
selected </span><span lang="en-US"><i>entity </i></span><span lang="en-US">toward
the absolute coordinates</span><span lang="en-US"> </span><span lang="en-US"><i>x</i></span><span lang="en-US">,
</span><span lang="en-US"><i>y</i></span><span lang="en-US">, </span><span lang="en-US"><i>z.</i></span><span lang="en-US">
T</span><span lang="en-US">he </span><span lang="en-US">rotation </span><span lang="en-US">will
happen gradually, at a given </span><span lang="en-US"><i>rate</i></span><span lang="en-US">
(a higher rate means a faster </span><span lang="en-US">rotation</span><span lang="en-US">),
at the next </span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">.
</span><span lang="en-US">If the entity is moved before it points at
its destination by other command, it will keep that in account and
correct its rotation.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ActVector"></a>
<b>Action* ActVector(Entity* entity, float x, float y, float z)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an action
that will </span><span lang="en-US">move</span><span lang="en-US">
the selected </span><span lang="en-US"><i>entity</i></span><span lang="en-US">
</span><span lang="en-US">by</span><span lang="en-US"> </span><span lang="en-US"><i>x</i></span><span lang="en-US">,
</span><span lang="en-US"><i>y</i></span><span lang="en-US">, </span><span lang="en-US"><i>z</i></span><span lang="en-US">
</span><span lang="en-US">at each</span><span lang="en-US">
</span><a href="#UpdateWorld">UpdateWorld</a><span lang="en-US">. </span><span lang="en-US">The
movement is always in the world coordinates, and is independent from
the entity rotation or parent. This action is useful to simulate wind
or gravity. This action is never completed, and will continue until
its stopped with </span><a href="#FreeAction">FreeAction</a><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm">More actions can be performed on the
same entity at the same time.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="ActWait"></a><span style="font-variant: small-caps"><b>Action*
Act</b></span><span style="font-variant: small-caps"><b>Wait</b></span><span style="font-variant: small-caps"><b>(float
</b></span><span style="font-variant: small-caps"><b>time</b></span><span style="font-variant: small-caps"><b>)</b></span></p>
<p style="margin-bottom: 0cm">Creates an action that does nothing,
and completes after a given number of <a href="#UpdateWorld">UpdateWorld</a>
cycles. If other actions are added to it with <a href="#AppendAction">AppendAction</a>,
they will be executed after the delay.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AddAnimSeq"></a>
<b>int AddAnimSeq(Entity* ent,int length)</b></p>
<p style="margin-bottom: 0cm">Creates an animation sequence for an
entity. This must be done before any animation keys set by <a href="#SetAnimKey">SetAnimKey</a>
can be used in an actual animation however this is optional. You may
use it to &quot;bake&quot; the frames you have added previously using
SetAnimKey. <br/>
<br/>
Returns the animation sequence number added. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AddMesh"></a>
<b>void AddMesh(Mesh* mesh1,Mesh* mesh2)</b></p>
<p>Add <em>source_mesh</em> to <em>dest_mesh</em>. All mesh data are
copied to the destination mesh, so you can also delete the source
mesh, after this command. 
</p>
<p>The size and rotation of the entity won't apply to the mesh: so,
if you have used commands like <a href="#RotateEntity">RotateEntity</a>,
or <a href="#ScaleEntity">ScaleEntity</a>, they won't affect the
copied mesh; use <a href="#RotateMesh">RotateMesh</a> and <a href="#ScaleMesh">ScaleMesh</a>,
instead. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AddRenderTarget"></a>
<b>void AddRenderTarget(PostFX* fx, int pass_no, int numColBufs, bool
depth, int format=8, float scale=1.0)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Defines the output
buffer generated by a pass, </span><span lang="en-US">in a post
processing effect </span><span lang="en-US"><i>fx</i></span><span lang="en-US">:
it allows to create one or more color buffers (those buffer contain
the rendered image), with different bit depth, and specifies if a
separate depth buffer is needed or not. The parameter </span><span lang="en-US"><i>pass_no</i></span><span lang="en-US">
defines which stage will create the buffers (stage 0 is the scene
rendering, stage 1 is the first shader, and so on). </span><span lang="en-US">The
parameter </span><span lang="en-US"><i>numColBufs</i></span><span lang="en-US">
sets how many color buffers must be created (this is useful when
using a shader than outputs different information on different
buffers: for example, in deferred shading one buffer can contain the
normal data, another the actual colors). The parameter </span><span lang="en-US"><i>depth</i></span><span lang="en-US">,
if true, specifies that the depth buffer must be included, as well.
The parameter </span><span lang="en-US"><i>format</i></span><span lang="en-US">
specifies the bit depth (8, 16 or 32) </span><span lang="en-US">that
must be used for the buffer (higher means more video memory usage,
and more precise color rendering: usually the improved quality cannot
be seen on the monitor, but it can be useful in HDR renderings). The
parameter </span><span lang="en-US"><i>scale</i></span><span lang="en-US">
allows to scale the rendering (a blurring shader, for example, wont
need a full scale buffer)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AddTriangle"></a>
<b>int AddTriangle(Surface* surf,int v0,int v1,int v2)</b></p>
<p>Creates a new triangle, and adds it to <em>surface</em>; also, it
returns the triangle index number (first triangle is 0). 
</p>
<p>Parameters <em>v0</em>, <em>v1</em> and <em>v2</em> are handles to
the three vertices of the triangle: to create vertices, the command
<a href="#AddVertex">AddVertex</a> can be used (it will also return
the handle of the created vertex). Of course, a vertex can also be
used in more than one triangle (so, if two triangles are adiacent,
they can share one or two vertices). 
</p>
<p>Every triangle is visible only from one side (backface culling):
to render an image faster, there is generally no need to draw the
polygons on the sides of the buildings facing away from the camera;
they are completely occluded by the sides facing the camera; the
order of vertices will determine wich side will be visible; the
command <a href="#FlipMesh">FlipMesh</a> will swap sides. To make a
triangle visible at both sides, the simplest solution is to create a
copy of the mesh, and flip it (it will require a double number of
triangles, one for each side). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AddVertex"></a>
<b>int AddVertex(Surface* surf,float x, float y,float z,float u,
float v,float w)</b></p>
<p>Add a vertex to <em>surface</em>; vertex coordinates are defined
by <em>x!</em>, <em>y!</em> and <em>z!</em> (floating-point
parameters); if the surface has a texture, texture mapping
coordinates can be specified with the optional parameters <em>u!</em>,
<em>v!</em> and <em>w!</em>. 
</p>
<p>The function will return an handle to the created vertex; this
handle can be used with the <a href="#AddTriangle">AddTriangle</a>
command. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AmbientLight"></a>
<b>void AmbientLight(float r,float g,float b)</b></p>
<p>Sets the ambient light, that will affect every object on the
scene, from all sides. 
</p>
<p>It's possible to set a value for every color component: for
example, 
</p>
<pre class="western" style="margin-bottom: 0.5cm">AmbientLight 255,0,0</pre><p>
Makes the light red; instead, 
</p>
<pre class="western" style="margin-bottom: 0.5cm">AmbientLight 0,0,0</pre><p>
will turn off the ambient light: so, unless there are other lights,
the scene will be black, and no object will be visible. 
</p>
<p>The ambient light is, by default, at 127,127,127; so, it will make
possible to see on the scene, even if there aren't other lights;
anyway, since the light comes from every side, there will be no
shading, and objects will look &quot;flat&quot;. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AmbientShader"></a>
<b>void AmbientShader(Shader* material)</b></p>
<p style="margin-bottom: 0cm">Sets a default shader to be used for
all the entities that dont have their own shader attached.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AntiAlias"></a>
<b>void AntiAlias(int samples)</b></p>
<p style="margin-bottom: 0cm"><i>samples</i> - true to enable
fullscreen antialiasing, false to disable. Defaults to false</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">If your OpenGL context supports
multisample, this command allows to enable it to make jagged lines
and other artifacts less noticeable, at expenses of a slower
rendering speed</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="Animate"></a><span style="font-variant: small-caps"><b>void
Animate(Entity* ent,int mode,float speed,int seq,int trans)</b></span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p>Animate an entity, if the entity has animation sequences. 
</p>
<p><em>mode</em> is the mode of animation. 
</p>
<ul>
	<li><p style="margin-bottom: 0cm">0: stop animation 
	</p></li>
	<li><p style="margin-bottom: 0cm">1: loop animation (default) 
	</p></li>
	<li><p style="margin-bottom: 0cm">2: ping-pong animation 
	</p></li>
	<li><p style="margin-bottom: 0cm">3: one-shot animation 
	</p></li>
	<li><p>4: manual animation (only for skeletal based animation)</p></li>
</ul>
<p><em>speed</em>: an higher value means a faster animation. A
negative value means a backward animation. Default is 1 
</p>
<p><em>sequence</em>: set which animation sequence will be played.
The same entity can have many sequences (walk, idle, jump, swim,
climb...). Default is 0. 
</p>
<p><em>transition</em>: used to tween between an entities current
position rotation and the first frame of animation. Default is 0</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="Animating"></a>
<b>int Animating(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns <strong>true</strong> if the
specified entity is currently animating. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AnimLength"></a>
<b>int AnimLength(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the length of the specified
entity's current animation sequence.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AnimSeq"></a>
<b>int AnimSeq(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the specified entity's current
animation sequence</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AnimTime"></a>
<b>float AnimTime(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the current animation time of
an entity.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="AppendAction"></a>
<b>void AppendAction(Action* first, Action* second)</b></p>
<p style="margin-bottom: 0cm">Appends an action to another: the
<i>second</i> action will be performed only when the <i>first</i>
action has completed. Several actions can be appended in chain: if
you append action B to action A, and action C to action B, they will
be performed in sequence A  B  C.</p>
<p style="margin-bottom: 0cm">More than one action can be appended to
the same action: if you append both action B and action C to action
A, once A has completed both B and C will start at the same time (the
only exception happens when action A is an <a href="#ActIterator">ActIterator</a>:
in this case action B will be performed, then action C, then B again,
then C again and so on).</p>
<p style="margin-bottom: 0cm">Appended actions dont necessarily
have to apply to the same entity of the action that triggered them,
they can apply to different entities as well.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BackBufferToTex"></a>
<b>void BackBufferToTex(Texture* tex,int frame)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">It converts the current screen back
buffer (usually, the rendered image) to a texture. The texture must
be created with <a href="#CreateTexture">CreateTexture</a>. If its
size is smaller than the screen size, only a portion of the screen
will be copied. The argument <i>tex </i><span style="font-style: normal">is
the texture handle. </span>Argument <i>frame </i><span style="font-style: normal">is
currently unused. </span>
</p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushAlpha"></a>
<b>void BrushAlpha(Brush* brush, float a)</b></p>
<p style="margin-bottom: 0cm">Set the alpha level (the transparency)
of a brush: <em>alphalevel!</em> is a floating point value, and it
must be in the range from 0 (completely transparent, invisible) to 1
(normal, no transparency at all). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushBlend"></a>
<b>void BrushBlend(Brush* brush,int blend)</b></p>
<p>Set the blending mode of a brush: <em>blend</em> value can be: 
</p>
<ul>
	<li><p style="margin-bottom: 0cm">1: alpha (default) 
	</p></li>
	<li><p style="margin-bottom: 0cm">2: multiply 
	</p></li>
	<li><p>3: add 
	</p></li>
</ul>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushColor"></a>
<b>void BrushColor(Brush* brush,float r,float g,float b)</b></p>
<p style="margin-bottom: 0cm">Set the color of a brush: <em>red!</em>,
<em>green!</em> and <em>blue!</em> are floating point values, ranging
from 0 to 255, that set colour levels. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushFX"></a>
<b>void BrushFX(Brush* brush,int fx)</b></p>
<p><em>brush</em> - brush handle 
</p>
<p><em>fx</em> - 
</p>
<ul>
	<li><p style="margin-bottom: 0cm">0: nothing (default) 
	</p></li>
	<li><p style="margin-bottom: 0cm">1: full-bright 
	</p></li>
	<li><p style="margin-bottom: 0cm">2: use vertex colors instead of
	brush color 
	</p></li>
	<li><p style="margin-bottom: 0cm">4: flatshaded 
	</p></li>
	<li><p style="margin-bottom: 0cm">8: disable fog 
	</p></li>
	<li><p>16: disable backface culling 
	</p></li>
</ul>
<p>Sets miscellaneous effects for a brush. 
</p>
<p>Flags can be added to combine two or more effects. For example,
specifying a flag of 3 (1+2) will result in a full-bright and
vertex-coloured brush. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushShininess"></a>
<b>void BrushShininess(Brush* brush,float s)</b></p>
<p style="margin-bottom: 0cm">Set the shininess of a brush: it means,
how brighter a surface will look when a light hits it. The value
<em>shininess</em> must be in a range from 0 to 1. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BrushTexture"></a>
<b>void BrushTexture(Brush* brush,Texture* tex,int frame,int index)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><i>brush</i> - brush handle<br/>
<i>texture</i> - texture
handle<br/>
<i>frame</i> (optional) - texture frame. Defaults to
0.<br/>
<i>index</i> (optional) - texture index. Defaults to 0.</p>
<p><br/>
<br/>

</p>
<p style="margin-bottom: 0.5cm">Assigns a texture to a brush.</p>
<p style="margin-bottom: 0.5cm">The optional frame parameter
specifies which animation frame, if any exist, should be assigned to
the brush.</p>
<p style="margin-bottom: 0.5cm">The optional index parameter
specifies texture layer that the texture should be assigned to.
Brushes have up to four texture layers, 0-3 inclusive.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="BufferToTex"></a>
<b>void BufferToTex(Texture* tex,unsigned char* buffer, int frame)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">It converts an image buffer to a
texture. The texture must be created with <a href="#CreateTexture">CreateTexture</a>.
The image buffer must be in format RGBA (each pixel is represented by
4 bytes: red, green, blue and alpha values), and it must have the
same width and height of the texture. The argument <i>tex </i><span style="font-style: normal">is
the texture handle, the argument </span><i>buffer</i><span style="font-style: normal">
is a pointer to the image buffer. </span>Argument <i>frame </i><span style="font-style: normal">is
currently unused. </span>
</p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraClsColor"></a>
<b>void CameraClsColor(Camera* cam, float r,float g,float b)</b></p>
<p style="margin-bottom: 0cm">Set the color that the camera will use
for background; usually, it is black (0,0,0). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraClsMode"></a>
<b>void CameraClsMode(Camera* cam,int cls_depth,int cls_zbuffer)</b></p>
<p style="margin-bottom: 0cm">Every time an image is rendered, just
before rendering the new image, the old image is usually deleted
(color buffer and z-buffer are erased). Setting flags to 0 will keep
the old data (it could be useful to achieve some strange effects, or
to combine two or more renderings in one) 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraFogColor"></a>
<b>void CameraFogColor(Camera* cam,float r,float g,float b)</b></p>
<p style="margin-bottom: 0cm">Set the color that the camera will use
for fog: it affects all the object that are &quot;fading away&quot;
in the distance, but not the background itself; usually, it is black
(0,0,0). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraFogMode"></a>
<b>void CameraFogMode(Camera* cam,int mode)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><i>camera</i> - sets camera fog mode<br/>
<i>mode</i> - fog
mode<br/>
0: no fog<br/>
1: linear fog</p>
<p style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p style="margin-bottom: 0.5cm">Sets the camera fog mode.</p>
<p style="margin-bottom: 0.5cm">This will enable/disable fogging, a
technique used to gradually fade out graphics the further they are
away from the camera. The can be used to avoid 'pop-up', the moment
at which 3D objects suddenly appear on the horizon.</p>
<p style="margin-bottom: 0.5cm">The default fog color is black and
the default fog range is 1-1000, although these can be changed by
using <a href="#CameraFogColor">CameraFogColor</a> and <a href="#CameraFogRange">CameraFogRange</a>
respectively.</p>
<p style="margin-bottom: 0.5cm">Each camera can have its own fog
mode, for multiple on-screen fog effects.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraFogRange"></a>
<b>void CameraFogRange(Camera* cam,float near,float far)</b></p>
<p>Set the fog range of the camera; since the range of the camera is
not infinite, object that are outside of the range will disappear
(otherwise, the system will have too many polygons to render); the
fog allows to slowly fade an object away, giving it the same color of
the background, to avoid a sudden disappearing. 
</p>
<p>The <em>near!</em> parameter is a floating point variable that
specify the minimum range of the fog effect; any object closer to the
camera won't be affected by fog. 
</p>
<p>The <em>far!</em> parameter is a floating point variable that
specify the maximum range of the fog; any object that is outside this
range will have the maximum fog effect, and will have the same color
of the background (thus being invisible). 
</p>
<p>See also <a href="#CameraFogColor">CameraFogColor</a>,
<a href="#CameraRange">CameraRange</a>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraPick"></a>
<b>Entity* CameraPick(Camera* cam,float x,float y)</b></p>
<p>Return the entity that is at the coordinates <em>x</em> and <em>y</em>
of the viewport (be careful: coordinates 0,0 point to the bottom left
angle of the viewport). If no entity is at the given coordinates, it
returns 0. 
</p>
<p>Not all entities can be picked with this method: to make an entity
&quot;pickable&quot;, the command <a href="#EntityPickMode">EntityPickMode</a>
is used. 
</p>
<p>Pitfall: if a mouse is used, mouse coordinates 0,0 refer to the
top left angle of a window: so, to get the correct <em>y</em>
coordinate, you need to use <em>screen_height</em> - <em>y</em>
(<em>screen_height</em>, of course, is the height of the viewport in
pixels) 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraProject"></a>
<b>void CameraProject(Camera* cam,float x,float y,float z)</b></p>
<p style="margin-bottom: 0cm">Projects the world coordinates x,y,z on
to the 2D screen. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraProjMatrix"></a>
<b>float* CameraProjMatrix(Camera* camera)</b></p>
<p style="margin-bottom: 0cm">Returns a pointer to the projection
matrix of a given camera</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraProjMode"></a>
<b>void  CameraProjMode(Camera* cam,int mode)</b></p>
<p><em>mode</em> - projection mode: 
</p>
<ul>
	<li><p style="margin-bottom: 0cm">0: no projection - disables camera
	(faster than HideEntity) 
	</p></li>
	<li><p style="margin-bottom: 0cm">1: perspective projection
	(default) 
	</p></li>
	<li><p>2: orthographic projection 
	</p></li>
</ul>
<p>Description: 
</p>
<p>Sets the camera projection mode. 
</p>
<p>The projection mode is the the technique used by OpenB3D to
display 3D graphics on the screen. Using projection mode 0, nothing
is displayed on the screen, and this is the fastest method of hiding
a camera. Using camera projection mode 1, the graphics are displayed
in their 'correct' form - and this is the default mode for a camera.
Camera projection mode 2 is a special type of projection, used for
displaying 3D graphics on screen, but in a 2D form - that is, no
sense of perspective will be given to the graphics. Two identical
objects at varying distances from the camera will both appear to be
the same size. Orthographic projection is useful for 3D editors,
where a sense of perspective is unimportant, and also certain games. 
</p>
<p>Use '<a href="#CameraZoom">CameraZoom</a>' to control the scale of
graphics rendered with orthographic projection. As a general rule,
using orthographic projection with the default camera zoom setting of
1 will result in graphics that are too 'zoomed-in' - changing the
camera zoom to 0.1 should fix this. 
</p>
<p>One thing to note with using camera project mode 2, is that
terrains will not be displayed correctly - this is because the level
of detail algorithm used by terrains relies on perspective in order
to work properly. Same limits apply to geospheres and isosurfaces</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="CameraRange"></a><span style="font-variant: small-caps"><b>void
 CameraRange(Camera* cam,float near,float far)</b></span> 
</p>
<p style="margin-bottom: 0cm">Sets camera range; any object with a
distance from the camera lower than <em>near</em> or higher than <em>far</em>
won't be drawn; this will make rendering faster. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraToTex"></a>
<b>void CameraToTex(Texture* tex, Camera* cam, int frame)</b></p>
<p style="margin-bottom: 0cm">Renders the output of a camera on a
texture. Shadows are rendered as well, other informations related to
stencils, or to postprocessing are ignored.  The camera viewport is
ignored, as well. The texture must be created with <a href="#CreateTexture">CreateTexture</a>.
The argument <i>tex </i><span style="font-style: normal">is the
texture handle, the argument </span><i>cam</i><span style="font-style: normal">
is the camera handle. </span>Argument <i>frame </i><span style="font-style: normal">is
currently unused. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CameraViewport"></a>
<b>void  CameraViewport(Camera* cam,int x,int y,int width,int height)</b></p>
<p>Set the camera viewport (the area of the screen where a camera
image is rendered); by default, all the screen (or window) is used. 
</p>
<p>This command allows to use only part of the screen, and so the
rest of the screen can be used to show panels, or also other camera
image (i.e. to achieve split-screen effect). Also, a smaller viewport
can be used to make a rear-view effect. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="CameraZoom"></a><span style="font-variant: small-caps"><b>void
 CameraZoom(Camera* cam,float zoom)</b></span></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set the zoom factor
of a camera: default is 1. A value lower than 1 will provide a
</span><span lang="en-US">wide</span><span lang="en-US">-</span><span lang="en-US">angle</span><span lang="en-US">
effect, a value greater than 1 will give a teleobjective effect.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ClearCollisions"></a>
<b>void ClearCollisions()</b></p>
<p style="margin-bottom: 0.5cm">Clears the collision information
list.</p>
<p>Whenever you use the <a href="#Collisions">Collisions</a> command
to enable collisions between two different entity types, information
is added to the collision list. This command clears that list, so
that no collisions will be detected until the Collisions command is
used again.</p>
<p>The command will not clear entity collision information. For
example, entity radius, type etc.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ClearSurface"></a>
<b>void ClearSurface(Surface* surf,bool clear_verts,bool clear_tris)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><i>surface</i> - surface handle<br/>
<i>clear_verts</i> (optional)
- true to remove all vertices from the specified surface, false not
to. Defaults to true.<br/>
<i>clear_triangles</i> (optional) - true
to remove all triangles from the specified surface, false not to.
Defaults to true.</p>
<p>Description:</p>
<p style="margin-bottom: 0.5cm">Removes all vertices and/or triangles
from a surface.</p>
<p style="margin-bottom: 0.5cm">This is useful for deleting sections
of mesh. The results will be instantly visible.</p>
<p style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ClearTextureFilters"></a>
<b>void ClearTextureFilters()</b></p>
<p style="margin-bottom: 0cm">Clears the current texture filter list.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ClearWorld"></a>
<b>void ClearWorld(bool entities,bool brushes,bool textures)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0.5cm">Clears a world of all entities,
brushes and/or textures.</p>
<p style="margin-bottom: 0.5cm">This is useful for when a game level
may have finished and you wish to free everything up in preparation
for loading new entities/brushes/textures without having to free
every entity/brush/texture individually.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionEntity"></a>
<b>Entity* CollisionEntity(Entity* ent,int index)</b></p>
<p style="margin-bottom: 0cm">Returns the other entity involved in a
particular collision. Index should be in the range
1...<a href="#CountCollisions">CountCollisions</a>( entity ),
inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="Collisions"></a>
<b>void Collisions(int src_no,int dest_no,int method_no,int
response_no)</b></p>
<p>Enable collision detecting; every time an <a href="#UpdateWorld">UpdateWorld</a>
command is performed, the library will automatically check if two or
more entities are colliding, and will react to that (so, you don't
need to check at every cycle if there are some colliding entity, the
library will do that for you) 
</p>
<p>Not all entities will be checked: only collision between entity of
type <em>src_type</em> with entities of type <em>dest_type</em> will
be detected (since some entities might not need to be checked for
collisions, or might need to react in a different way) 
</p>
<p>You can set the type of an entity with <a href="#EntityType">EntityType</a>
(the type is a simple number: all entities of the same type will
behave in the same way): a negative type would mean that the entity
has to be checked for dynamic collisions (slower, but it works even
when the target is moving)</p>
<p><em>method</em> is the collision detection method: 
</p>
<p>1: ellipsoid-to-ellipsoid collisions (fastest, but not much
accurate: you need to set ellipsoid radius with <em><a href="#EntityRadius">EntityRadius</a></em>)
</p>
<p>2: ellipsoid-to-polygon collisions (the most precise, but slower) 
</p>
<p>3: ellipsoid-to-box collisions (need to set box size with
<em><a href="#EntityBox">EntityBox</a></em>) 
</p>
<p><em>response</em> is what the source entity does when a collision
occurs: 
</p>
<p>1: entity will stop 
</p>
<p>2: slide1 - full sliding collision 
</p>
<p>3: slide2 - prevent entities from sliding down slopes 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionNX"></a>
<b>float CollisionNX(Entity* ent,int index)</b></p>
<p>Returns the x component of the normal of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionNY"></a>
<b>float CollisionNY(Entity* ent,int index)</b></p>
<p>Returns the y component of the normal of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionNZ"></a>
<b>float CollisionNZ(Entity* ent,int index)</b></p>
<p>Returns the z component of the normal of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionSurface"></a>
<b>Surface* CollisionSurface(Entity* ent,int index)</b></p>
<p>Returns the handle of the surface belonging to the specified
entity that was closest to the point of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionTime"></a>
<b>float CollisionTime(Entity* ent,int index)</b></p>
<p>Returns the time taken to calculate a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionTriangle"></a>
<b>int CollisionTriangle(Entity* ent,int index)</b></p>
<p>Returns the index number of the triangle belonging to the
specified entity that was closest to the point of a particular
collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionX"></a>
<b>float CollisionX(Entity* ent,int index)</b></p>
<p>Returns the world x coordinate of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionY"></a>
<b>float CollisionY(Entity* ent,int index)</b></p>
<p>Returns the world y coordinate of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CollisionZ"></a>
<b>float CollisionZ(Entity* ent,int index)</b></p>
<p>Returns the world z coordinate of a particular collision. 
</p>
<p>Index should be in the range 1...<a href="#CountCollisions">CountCollisions</a>(
entity ) inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CopyMesh"></a>
<b>Mesh* CopyMesh(Mesh* mesh,Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Creates a copy of a mesh and returns
the newly-created mesh's handle. 
</p>
<p>The difference between CopyMesh and <a href="#CopyEntity">CopyEntity</a>
is that children entities are not copied (and that includes bones, or
attached entities). So, CopyMesh is not recommended for animated
meshes.</p>
<p>CopyMesh is identical to performing new_mesh=CreateMesh()&nbsp;:
AddMesh mesh,new_mesh 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountChildren"></a>
<b>int CountChildren(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the number of children of an
entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountCollisions"></a>
<b>int CountCollisions(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns how many collisions an entity
was involved in during the last UpdateWorld. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CopyEntity"></a>
<b>Entity* CopyEntity(Entity* ent,Entity* parent)</b></p>
<p>Creates a copy of an entity and returns the handle of the newly
created copy. Any entity (a mesh, a light, a pivot, a terrain...) can
be copied. Children entities are copied as well.</p>
<p>If a parent entity is specified, the copied entity will be created
at the parent entity's position. Otherwise, it will be created at
0,0,0. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountBones"></a>
<b>int CountBones(Mesh* mesh)</b></p>
<p style="margin-bottom: 0cm">Returns the number of bones that are
used in <em>mesh</em> 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountSurfaces"></a>
<b>int CountSurfaces(Mesh* mesh)</b></p>
<p style="margin-bottom: 0cm">Returns the number of surfaces that are
used in <em>mesh</em> (a mesh can have more than one surface) 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountTriangles"></a>
<b>int CountTriangles(Surface* surf)</b></p>
<p style="margin-bottom: 0cm">Returns the number of triangles in a
surface.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CountVertices"></a>
<b>int CountVertices(Surface* surf)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the number
of </span><span lang="en-US">vertices</span><span lang="en-US"> in a
surface.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="CreateBlob"></a><span style="font-variant: small-caps"><b>Blob*
CreateBlob(Fluid* fluid, float radius, Entity* parent_ent)</b></span>
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a blob,
also called a metaball, from a given fluid. A blob will react
only with other blobs of the same isosurface, and it is basically
</span><span lang="en-US">similar to a sphere made of goo, that can
stick to other ones and merge with them. The size is determined by
the </span><span lang="en-US"><i>radius</i></span><span lang="en-US">;
if the radius is negative, the blob wont be visible, but if it is
moved close to other ones it can repel them, or appear like a hole.</span></p>
<p style="margin-bottom: 0cm">Blobs are useful to show fluids, atoms
and molecules, or organic-like structures. They cannot have a color
or a texture, and they will use the parameters of their fluid entity</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateBone"></a>
<b>Bone* CreateBone(Mesh* mesh, Entity* parent_ent)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a Bone
entity, that will be used for the animation of </span><span lang="en-US"><i>mesh.
</i></span><span lang="en-US"><span style="font-style: normal">Bones
can later be set to affect the mesh vertices with the command
</span></span><a href="#SkinMesh">SkinMesh</a><span lang="en-US"><span style="font-style: normal">.
</span></span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateBrush"></a>
<b>Brush* CreateBrush(float r,float g,float b)</b></p>
<p style="margin-bottom: 0.5cm">Creates a brush and returns a brush
handle.</p>
<p>The optional green, red and blue values allow you to set the
colour of the brush. Values should be in the range 0-255. If omitted
the values default to 255.<br/>
<br/>
A brush is a collection of
properties such as Colour, Alpha, Shininess, Texture etc that are all
stored as part of the brush. Then, all these properties can be
applied to an entity, mesh or surface at once just by using
<a href="#PaintEntity">PaintEntity</a>, <a href="#PaintMesh">PaintMesh</a>
or <a href="#PaintSurface">PaintSurface</a>.</p>
<p>When creating your own mesh, if you wish for certain surfaces to
look differently from one another, then you will need to use brushes
to paint individual surfaces. Using commands such as EntityColor,
EntityAlpha will apply the effect to all surfaces at once, which may
not be what you wish to achieve.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateCamera"></a>
<b>Camera* CreateCamera(Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm">Creates a camera entity and returns
its handle.</p>
<p>Without at least one camera, you won't be able to see anything in
your 3D world. With more than one camera, you will be to achieve
effect such as split-screen modes and rear-view mirrors.</p>
<p>A camera by default renders to the backbuffer. If you wish to
display 3D graphics on a texture you can use <a href="#CameraToTex">CameraToTex</a>.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the camera so that when the parent is moved the child
camera will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p><br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateConstraint"></a>
<b>Constraint* CreateConstraint(Entity* p1, Entity* p2, float length)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">It creates a bound
between the entities p1 and p2, forcing them to maintain a distance
of </span><span lang="en-US"><i>length</i></span><span lang="en-US">
between them. Both entities can still be moved, but the movements of
one will influence the movement of the other. An entity can have more
than one constraint, with different entities. Constraints can be very
useful in physics simulation</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateCone"></a>
<b>Mesh* CreateCone(int segments,bool solid,Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><i>segments</i> (optional) - cone
detail. Defaults to 8.<br/>
<i>parent</i> (optional) - parent entity
of cone<br/>
<i>solid</i> (optional) - true for a cone with a base,
false for a cone without a base. Defaults to true.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Creates a cone mesh/entity and returns
its handle.</p>
<p>The cone will be centred at 0,0,0 and the base of the cone will
have a radius of 1.</p>
<p>The <i>segments</i> value must be in the range 3-100 inclusive.</p>
<p>Example segments values (solid=true):<br/>
4: 6 polygons - a
pyramid<br/>
8: 14 polygons - bare minimum amount of polygons for a
cone<br/>
16: 30 polygons - smooth cone at medium-high distances<br/>
32:
62 polygons - smooth cone at close distances</p>
<p><font size="3" style="font-size: 12pt">The optional <i>parent</i>
parameter allow you to specify a parent entity for the cone so that
when the parent is moved the child cone will move with it. However,
this relationship is one way; applying movement commands to the child
will not affect the parent.</font></p>
<p><br/>
<br/>

</p>
<p><br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateCube"></a>
<b>Mesh* CreateCube(Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Creates a cube mesh/entity and returns
its handle.</p>
<p>The cube will extend from -1,-1,-1 to +1,+1,+1.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the cube so that when the parent is moved the child cube
will move with it. However, this relationship is one way; applying
movement commands to the child will not affect the parent.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateCylinder"></a>
<b>Mesh* CreateCylinder(int segments,bool solid,Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">segments (optional)
- </span><span lang="en-US">cylinder</span><span lang="en-US">
detail. Defaults to 8.<br/>
parent (optional) - parent entity of
cone<br/>
solid (optional) - true for a c</span><span lang="en-US">ylinder</span><span lang="en-US">
with a base, false for a </span><span lang="en-US">tube</span><span lang="en-US">.
Defaults to true.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Description</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Creates a cylinder mesh/entity and
returns its handle.</p>
<p>The cylinder will be centred at 0,0,0 and will have a radius of 1.</p>
<p>The <i>segments</i> value must be in the range 3-100 inclusive.</p>
<p>Example segments values (solid=true):<br/>
<font size="3" style="font-size: 12pt">3:
8 polygons - a prism<br/>
8: 28 polygons - bare minimum amount of
polygons for a cylinder<br/>
16: 60 polygons - smooth cylinder at
medium-high distances<br/>
32: 124 polygons - smooth cylinder at
close distances</font></p>
<p><font size="3" style="font-size: 12pt">The optional </font><font size="3" style="font-size: 12pt"><i>parent</i></font><font size="3" style="font-size: 12pt">
parameter allow you to specify a parent entity for the </font><font size="3" style="font-size: 12pt">cylinder</font><font size="3" style="font-size: 12pt">
so that when the parent is moved the child cone will move with it.
However, this relationship is one way; applying movement commands to
the child will not affect the parent.</font></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateFluid"></a>
<b>Fluid* CreateFluid()</b></p>
<p style="margin-bottom: 0cm">Creates a fluid entity, or, more
specifically, an isosurface. Isosurfaces are 3d objects that are not
defined by a list of triangles, but by a 3d field, that can be based
on a given array, or on a mathematical function: the isosurface
represents points of constant value inside that field. 
</p>
<p style="margin-bottom: 0cm">An application for isosurfaces is the
rendering of metaballs, or blobs, with the command <a href="#CreateBlob">CreateBlob</a>.
</p>
<p style="margin-bottom: 0cm">To create textured blobs, the texture,
brush, or shader has to be applied to the fluid entity, and not to
the blob entity.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateGeosphere"></a>
<b>Terrain* CreateGeosphere(int size, Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm"><span lang="en-US">Creates a
</span><span lang="en-US">geosphere</span><span lang="en-US">
</span><span lang="en-US">(planet) </span><span lang="en-US">entity
and returns its handle.</span></p>
<p>A geosphere is a special type of polygon object that uses
real-time level of detail (LOD) to display a spherical landscape
which should theoretically consist of over millions polygons with
only a few thousand. The way it does this is by constantly
rearranging a certain amount of polygons to display high levels of
detail close to the viewer and low levels further away.</p>
<p>This constant rearrangement of polygons is noticeable however, and
is an well-known side-effect of all LOD landscapes. This 'pop-in'
effect can be reduced though in lots of ways, as the other terrain
help files will go on to explain.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the terrain so that when the parent is moved the child
terrain will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p><br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateMesh"></a>
<b>Mesh* CreateMesh(Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Create a 'blank' mesh entity and
returns its handle. <br/>
<br/>
When a mesh is first created it has
no surfaces, vertices or triangles associated with it. <br/>
<br/>
To
add geometry to this mesh, you will need to: <br/>
<br/>
CreateSurface()
; To make a surface <br/>
AddVertex ; You will need to add at least 3
to make a Triangle <br/>
AddTriangle ; This will add a triangle by
connecting the Vertices (points) you added to the mesh. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"> 
</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateLight"></a>
<b>Light* CreateLight(int light_type,Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm">Creates a light.</p>
<p>Lights work by affecting the colour of all vertices within the
light's range. You need at to create at least one light if you wish
to use 3D graphics otherwise everything will appear flat.<br/>
<br/>
The
optional type parameter allows you to specify the type of light you
wish to create. A value of 1 creates a directional light. This works
similar to a sun shining on a house. All walls facing a certain
direction are lit the same. How much they are lit by depends on the
angle of the light reaching them.<br/>
<br/>
A value of 2 creates a
point light. This works a little bit like a light bulb in a house,
starting from a central point and gradually fading outwards.<br/>
<br/>
A
value of 3 creates a spot light. This is a cone of light. This works
similar to shining a torch in a house. It starts with an inner angle
of light, and then extends towards an outer angle of light.</p>
<p>For a light of type 1, only direction is used to calculate the
light, while the light position is ignored. For a light of type 2,
only position is used to calculate the light, direction is ignored. A
light of type 3 is calculated using both direction and position.</p>
<p>A high number of light affects rendering speed. Usually 8 lights
can be supported, no more. 
</p>
<p>A light can cast shadows, although they have to be created with
CreateShadow.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the light so that when the parent is moved the child light
will move with it. However, this relationship is one way; applying
movement commands to the child will not affect the parent.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateOcTree"></a>
<b>OcTree* CreateOcTree(float width, float height, float depth,
Entity* parent_ent=0)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates an octree of
given </span><span lang="en-US"><i>width</i></span><span lang="en-US">,
</span><span lang="en-US"><i>height</i></span><span lang="en-US"> and
</span><span lang="en-US"><i>depth</i></span><span lang="en-US">. </span><span lang="en-US">An
octree </span><span lang="en-US">allows to manage several static
entities, allowing to create complex structures made of blocks (in a
way similar to what tilemaps do in 2d graphics), </span><span lang="en-US">and
also allowing LOD (by showing smaller blocks only when they are close
enough). An octree can be imagined as a cube subdivided in eight
smaller cubes, each one subdivided again. So, the first level will be
a 2x2x2=8 blocks structure, at the second level it will be a 4x4x4=64
blocks structure, and so on.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><span lang="en-US">The optional </span><span lang="en-US"><i>parent</i></span><span lang="en-US">
parameter allow you to specify a parent entity for the terrain so
that when the parent is moved the child terrain will move with it.
However, this relationship is one way; applying movement commands to
the child will not affect the parent.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateParticleEmitter"></a>
<b>ParticleEmitter* CreateParticleEmitter(Entity* particle, Entity*
parent_ent=0)</b></p>
<p style="margin-bottom: 0cm">Creates an emitter entity. An emitter
is an entity that periodically produces new entities of a given kind
(usually particle sprites), and launches them: those entities have a
limited lifespan, then they are automatically removed. They are
produced by duplicating a given <i>particle</i> entity: the
recommended entity to be used for that is a sprite with
<a href="#SpriteRenderMode">SpriteRenderMode</a> set to 3, but any
kind of entity can be used, including blobs (for water simulation) or
even other emitters (for firework effects, for example)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><span lang="en-US">The optional </span><span lang="en-US"><i>parent</i></span><span lang="en-US">
parameter allow you to specify a parent entity for the terrain so
that when the parent is moved the child terrain will move with it.
However, this relationship is one way; applying movement commands to
the child will not affect the parent.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreatePivot"></a>
<b>Pivot* CreatePivot(Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Creates a pivot entity. <br/>
<br/>
A
pivot entity is an invisible point in 3D space that's main use is to
act as a parent entity to other entities. The pivot can then be used
to control lots of entities at once, or act as new centre of rotation
for other entities. <br/>
<br/>
To enforce this relationship; use
EntityParent or make use of the optional parent entity parameter
available with all entity load/creation commands. <br/>
<br/>
Indeed,
this parameter is also available with the CreatePivot command if you
wish for the pivot to have a parent entity itself. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreatePlane"></a>
<b>Mesh* CreatePlane(int divisions,Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a plane
entity and returns its handle. <br/>
<br/>
A plane entity is
basically a flat, infinite 'ground'. It is useful for outdoor games
where you never want the player to see/reach the edge of the game
world. <br/>
<br/>
The optional </span><span lang="en-US"><i>div</i></span><span lang="en-US"><i>ision</i></span><span lang="en-US"><i>s</i></span><span lang="en-US">
parameter </span><span lang="en-US">is currently unused.</span><span lang="en-US"><br/>
<br/>
The
</span><span lang="en-US"><span style="font-style: normal">optional</span></span><span lang="en-US">
</span><span lang="en-US"><i>parent</i></span><span lang="en-US">
parameter allows you to specify a parent entity for the plane so that
when the parent is moved the child plane will move with it. However,
this relationship is one way; applying movement commands to the child
will not affect the parent. <br/>
</span><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreatePostFX"></a>
<b>PostFX* CreatePostFX(Camera* camera, int passes=1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a
post-processing effect. Post-processing effects are a special kind of
shaders that are applied on the entire visible area, after the scene
has been rendered, and not on the single entity. They can be applied
even on scene that feature entities using custom shaders (they can
also cooperate with entity shaders in some special cases, like
deferred </span><span lang="en-US">shading). They can be used, for
example, to render a scene in black and white, or to simulate a night
vision device, or a fisheye lens, and so on. </span>
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">A post-processing
effect works by rendering the scene on a texture, then applying that
texture to a rectangular surface as big as the visible area, and
rendering it using a custom shader. This operation can be performed
more than once, to use different shader programs (for example, in one
step colors are changed, in the next step the image is blurred, and
so on). The parameter </span><span lang="en-US"><i>passes</i></span><span lang="en-US">
specifies how many steps are needed.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateQuad"></a>
<b>Mesh* CreateQuad(Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a </span><span lang="en-US">quad</span><span lang="en-US">
entity and returns its handle. <br/>
<br/>
A </span><span lang="en-US">quad
</span><span lang="en-US">entity is basically a flat </span><span lang="en-US">square,
useful for tiles.</span><span lang="en-US"><br/>
<br/>
The optional
</span><span lang="en-US"><i>parent</i></span><span lang="en-US">
parameter allows you to specify a parent entity for the plane so that
when the parent is moved the child plane will move with it. However,
this relationship is one way; applying movement commands to the child
will not affect the parent. <br/>
</span><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateRigidBody"></a>
<b>RigidBody* CreateRigidBody(Entity* body, Entity* p1, Entity* p2,
Entity* p3, Entity* p4)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">A RigidBody is a
particular kind of entity: it is not affected anymore by commands
like TurnEntity, MoveEntity, PositionEntity, RotateEntity, or
ScaleEntity; </span><span lang="en-US">its behavior is determined by
the four entities </span><span lang="en-US"><i>p1</i></span><span lang="en-US">,
</span><span lang="en-US"><i>p2</i></span><span lang="en-US">, </span><span lang="en-US"><i>p3
</i></span><span lang="en-US">and </span><span lang="en-US"><i>p4
</i></span><span lang="en-US">(usually those entities are pivots).</span><span lang="en-US">
Its position is determined by p1s position, and its orientation is
determined by the other entities that will point where </span><span lang="en-US">the
forward, the top, and the right are; if the entities are not
correctly aligned, the </span><span lang="en-US"><i>body</i></span><span lang="en-US">
entity might be deformed. For that reason, the entities used as </span><span lang="en-US">
</span><span lang="en-US"><i>p1</i></span><span lang="en-US">, </span><span lang="en-US"><i>p2</i></span><span lang="en-US">,
</span><span lang="en-US"><i>p3 </i></span><span lang="en-US">and </span><span lang="en-US"><i>p4
</i></span><span lang="en-US"><span style="font-style: normal">should
be connected using constraints made with </span></span><a href="#CreateConstraint">CreateConstraint</a><span lang="en-US"><span style="font-style: normal">,
to ensure they will always move together.</span></span></p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-style: normal; margin-bottom: 0cm">Combined with
constraints, CreateRigidBody allows to build a simple physics engine</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateShader"></a>
<b>Shader* CreateShader(char* ShaderName, char* VshaderString, char*
FshaderString)</b></p>
<p style="margin-bottom: 0cm">Creates a shader. A shader is a special
program that is not run on the CPU, but on the GPU, and its
written in GLSL (GL Shading Language). It requires a name, and two
strings containing the source codes of the two shaders, called Vertex
Shader and Fragment Shader</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateShaderVGF"></a>
<b>Shader* CreateShaderVGF(char* ShaderName, char* VshaderString,
char* GshaderString, char* FshaderString)</b></p>
<p style="margin-bottom: 0cm">Creates a shader. A shader is a special
program that is not run on the CPU, but on the GPU, and its
written in GLSL (GL Shading Language). It requires a name, and three
strings containing the source codes of the two shaders, called Vertex
Shader, Geometry Shader and Fragment Shader</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateShadow"></a>
<b>ShadowObject* CreateShadow(Mesh* parent, char Static)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Cause the </span><span lang="en-US"><i>parent</i></span><span lang="en-US">
mesh to cast a shadow. The shadow is automatically calculated from
the light position, and if there is more than one light active, more
shadows are produced. The </span><span lang="en-US"><i>Static</i></span><span lang="en-US"><span style="font-style: normal">
parameter, if true, is used to specify that the shadow must not be
updated after its creation; normally, a shadow is updated each frame
according to light and mesh position, and to mesh animation. Static
shadows are not updated, so they should be used only for static
meshes, and only if the light is not moved as well. Rendering of a
static shadow is of course much faster.</span></span></p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">T</span></span><span lang="en-US"><span style="font-style: normal">o
render shadows, stencil buffer must be enabled. Shadows could
interfere with other stencil operations. The algorithm used (Z Fail)
has some side-effects, like the fact that shadows are rendered
through objects, as well (that issue can be fixed by ensuring that
any object that receives a shadow is a shadow caster as well). The
choice of stencil shadows allows entities that are supposed to
receive a shadow to use custom shaders with no interferences.</span></span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateSphere"></a>
<b>Mesh* CreateSphere(int segments,Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm">Creates a sphere mesh/entity and
returns its handle.</p>
<p>The sphere will be centred at 0,0,0 and will have a radius of 1.</p>
<p>The <i>segments</i> value must be in the range 2-100 inclusive.</p>
<p>Example segments values:<br/>
8: 224 polygons - bare minimum
amount of polygons for a sphere<br/>
16: 960 polygons - smooth
looking sphere at medium-high distances<br/>
32: 3968 polygons -
smooth sphere at close distances</p>
<p><font size="3" style="font-size: 12pt">The optional <i>parent</i>
parameter allow you to specify a parent entity for the sphere so that
when the parent is moved the child sphere will move with it. However,
this relationship is one way; applying movement commands to the child
will not affect the parent.</font></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateSprite"></a>
<b>Sprite* CreateSprite(Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm">Creates a sprite entity and returns
its handle.</p>
<p>The sprite will be positioned at 0,0,0 and extend from 1,-1 to
+1,+1.</p>
<p>A sprite entity is a flat, square (which can be made rectangular
by scaling it) 3D object.</p>
<p>Sprites have two real strengths. The first is that they consist of
only two polygons; meaning you can use many of them at once. This
makes them ideal for particle effects and 2D-using-3D games where you
want lots of sprites on-screen at once.</p>
<p>Secondly, sprites can be assigned a view mode using
<a href="#SpriteViewMode">SpriteViewMode</a>. By default this view
mode is set to 1, which means the sprite will always face the camera.
So no matter what the orientation of the camera is relative to the
sprite, you will never actually notice that they are flat; by giving
them a spherical texture, you can make them appear to look no
different than a normal sphere.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the sprite so that when the parent is moved the child
sprite will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateStencil"></a>
<b>Stencil* CreateStencil()</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Creates a stencil:
stencils are used to limit the next rendering to only a portion of
the visible area: that portion can be shaped through one or more
meshes built for that purpose. Stencils can be useful to simulate
shadows, or light spots (by rendering part of a scene with different
light conditions), </span><span lang="en-US">or also to simulate a
portal leading to a different place (by rendering a different
scene, viewed by a different camera, inside the stencil)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateSurface"></a>
<b>Surface* CreateSurface(Mesh* mesh,Brush* brush)</b></p>
<p style="margin-bottom: 0.5cm">Creates a surface attached to a mesh
and returns the surface's handle.</p>
<p>Surfaces are sections of mesh which are then used to attach
triangles to. You must have at least one surface per mesh in order to
create a visible mesh, however you can use as many as you like.
Splitting a mesh up into lots of sections allows you to affect those
sections individually, which can be a lot more useful than if all the
surfaces are combined into just one.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateTerrain"></a>
<b>Terrain* CreateTerrain(int size, Entity* parent)</b></p>
<p style="margin-bottom: 0.5cm">Creates a terrain entity and returns
its handle.</p>
<p>The terrain extends from 0,0,0 to <i>grid_size</i>,1,<i>grid_size</i>.</p>
<p>A terrain is a special type of polygon object that uses real-time
level of detail (LOD) to display landscapes which should
theoretically consist of over a million polygons with only a few
thousand. The way it does this is by constantly rearranging a certain
amount of polygons to display high levels of detail close to the
viewer and low levels further away.</p>
<p>This constant rearrangement of polygons is noticeable however, and
is an well-known side-effect of all LOD landscapes. This 'pop-in'
effect can be reduced though in lots of ways, as the other terrain
help files will go on to explain.</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the terrain so that when the parent is moved the child
terrain will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="CreateTexture"></a><span style="font-variant: small-caps"><b>Texture*
CreateTexture(int width,int height,int flags,int frames)</b></span> 
</p>
<p><em>Width</em> and <em>height</em> are the size of the texture.
Note that the actual texture size may be different from the width and
height requested, as different types of 3D hardware support different
sizes of texture. 
</p>
<p>The optional <i>flags</i> parameter allows you to apply certain
effects to the texture. Flags can be added to combine two or more
effects, e.g. 3 (1+2) = texture with color and alpha maps. 
</p>
<p>Here some more detailed descriptions of the flags: 
</p>
<p><strong>1</strong>: <strong>Color</strong> - colour map, what you
see is what you get. 
</p>
<p><strong>2</strong>: <strong>Alpha</strong> - alpha map. If an
image contains an alpha map, this will be used to make certain areas
of the texture transparent. Otherwise, the colour map will be used as
an alpha map. With alpha maps, the dark areas always equal
high-transparency, light areas equal low-transparency. 
</p>
<p><strong>4</strong>: <strong>Masked</strong> - all areas of a
texture coloured 0,0,0 will not be drawn to the screen. 
</p>
<p><strong>8</strong>: <strong>Mipmapped</strong> - low detail
versions of the texture will be used at high distance. Results in a
smooth, blurred look. 
</p>
<p><strong>16</strong>: <strong>Clamp u</strong> - Any part of a
texture that lies outsides the U coordinates of 0-1 will not be
drawn. Prevents texture-wrapping. 
</p>
<p><strong>32</strong>: <strong>Clamp v</strong> - Any part of a
texture that lies outsides the v coordinates of 0-1 will not be
drawn. Prevents texture-wrapping. 
</p>
<p><strong>64</strong>: <strong>Spherical environment map</strong> -
a form of environment mapping. This works by taking a single image,
and then applying it to a 3D mesh in such a way that the image
appears to be reflected. When used with a texture that contains light
sources, it can give some meshes such as a teapot a shiny appearance.
</p>
<p><strong>128</strong>: <strong>Cubic environment map</strong> - a
form of environment mapping. Cube mapping is similar to spherical
mapping, except it uses six images each representing a particular
'face' of an imaginary cube, to give the appearance of an image that
perfectly reflects its surroundings. 
</p>
<p>When creating cubic environment maps with the CreateTexture
command, cubemap textures <em>must</em> be square 'power of 2' sizes.
See the SetCubeFace command for information on how to then draw to
the cubemap. 
</p>
<p>When loading cubic environments maps into OpenB3D using
<a href="#LoadAnimTexture">LoadAnimTexture</a>, all six images
relating to the six faces of the cube must be contained within the
one texture, and be laid out in a horizontal strip in the following
order - left, forward, right, backward, up, down. The images
comprising the cubemap must all be power of two sizes. 
</p>
<p>Please note that not some older graphics cards do not support
cubic mapping. 
</p>
<p>Once you have created a texture, use <a href="#BufferToTex">BufferToTex</a>
to copy an image to it. To display 3D graphics on a texture, one
option is to copy from the backbuffer to the texturebuffer, another
is to directly render the image from a camera to the texture. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="CreateVoxelSprite"></a>
<b>VoxelSprite* CreateVoxelSprite(int slices, Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Creates a voxel sprite and returns its
handle.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">A voxel sprite works more or less like
a regular sprites, but it uses a 3d texture instead of a 2d one, and
it is not square, but cubic. It can be seen as a pile of different
quads, each one with a different texture, that represent a slice of
the complete object. The slice parameter sets the number of quads
used.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">As result, the voxel
sprite</span><span lang="en-US"> </span><span lang="en-US">can be
turned, showing different sides, as a true 3d object.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the terrain so that when the parent is moved the child
terrain will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="DeltaPitch"></a>
<b><span lang="en-US">float DeltaPitch(Entity* src_entity,Entity*
</span><span lang="en-US">dest</span><span lang="en-US">_entity)</span></b></p>
<p style="margin-bottom: 0cm">Returns the pitch angle, that
<i>src_entity</i> should be rotated by in order to face <i>dest_entity</i>.
<br/>
<br/>
This command can be used to be point one entity at
another, rotating on the x axis only. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="DeltaYaw"></a>
<b>float DeltaYaw(Entity* src_entity,Entity* dest_entity)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">yaw</span><span lang="en-US">
angle, that </span><span lang="en-US"><i>src_entity</i></span><span lang="en-US">
should be rotated by in order to face </span><span lang="en-US"><i>dest_entity</i></span><span lang="en-US">.
<br/>
<br/>
This command can be used to be point one entity at
another, rotating on the </span><span lang="en-US">y</span><span lang="en-US">
axis only. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="DepthBufferToTex"></a>
<b>void DepthBufferToTex( Texture* tex, Camera* camera=0 )</b></p>
<p style="margin-bottom: 0cm">It converts the depth buffer to a
texture. If a <i>camera</i> is specified, it will use the depth
buffer of the picture rendered from that camera, otherwise, if no
camera is specified, it will use the current depth buffer. The
texture must be created with <a href="#CreateTexture">CreateTexture</a>.
The argument <i>tex </i><span style="font-style: normal">is the
texture handle.</span></p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-style: normal; margin-bottom: 0cm">Rendering a depth
buffer to a texture (that will look like a gray scale image) can be
useful for some shaders that need that information, since shaders by
default cannot read the depth buffer directly.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterVector"></a>
<b>void EmitterVector(ParticleEmitter* emitter, float x, float y,
float z)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Provides an
acceleration to the particles coming from </span><span lang="en-US"><i>emitter</i></span><span lang="en-US">,
to simulate the effects of gravity, or of wind. The three components
</span><span lang="en-US"><i>x</i></span><span lang="en-US">, </span><span lang="en-US"><i>y</i></span><span lang="en-US">
and </span><span lang="en-US"><i>z</i></span><span lang="en-US"> of
such acceleration are added to the absolute speed of each particle at
each frame, for all the particle life.</span></p>
<p style="margin-bottom: 0cm"> 
</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterRate"></a>
<b>void EmitterRate(ParticleEmitter* emitter, float r)</b></p>
<p style="margin-bottom: 0cm">Sets the frequency of emission of new
particle for <i>emitter</i><span style="font-style: normal">. The
parameter </span><i>r</i><span style="font-style: normal"> is the
emission rate: a value of 1 means a new particle is emitted at each
update, a lower value means a lower rate. A value of 0 disables the
emitter.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterParticleLife"></a>
<b>void EmitterParticleLife(ParticleEmitter* emitter, int l)</b></p>
<p style="margin-bottom: 0cm">Sets the lifetime of particles emitted
by <i>emitter</i><span style="font-style: normal">. The parameter </span><i>l</i><span style="font-style: normal">
is the number of frames after a particle is removed. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterParticleFunction"></a>
<b>void EmitterParticleFunction(ParticleEmitter* emitter, void
(*EmitterFunction)(Entity*, int))</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">S</span><span lang="en-US">ets
a </span><span lang="en-US">custom </span><span lang="en-US">function
that will manage every particle produced by </span><span lang="en-US"><i>emitter</i></span><span lang="en-US">.
must be declared using C calling convention, and must accept an
entity and an integer number as pa</span><span lang="en-US">rameters.</span></p>
<p style="margin-bottom: 0cm">The entity is the particle, and the
numeric parameter is its current lifetime: the custom function can be
used to control the fading, the orientation, the scaling factor, and
almost every other parameter, based on the particle lifetime (it must
not use static variables, since it is called for each particle). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterParticleSpeed"></a>
<b>void EmitterParticleSpeed(ParticleEmitter* emitter, float speed)</b></p>
<p style="margin-bottom: 0cm">Sets the <i>speed</i> of a particle,
when it is produced by <i>emitter</i><span style="font-style: normal">.
The particle will move in the same direction of the emitter, at the
given speed, that will remain constant for all its lifetime unless
its affected by EmitterVector</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EmitterVariance"></a>
<b>void EmitterVariance(ParticleEmitter* emitter, float variance)</b></p>
<p style="margin-bottom: 0cm">Set the <i>variance</i> in speed and
direction of particles coming from <i>emitter</i>. A variance of zero
means that all particles will go exactly in the same direction at the
same speed. Any value greater than zero will introduce a random
change, different for each particle, in their speed and  direction,
to cause them to spread more. The variation will be random, but never
greater than <i>variance</i>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityAlpha"></a>
<b>void EntityAlpha(Entity* ent,float alpha)</b></p>
<p style="margin-bottom: 0cm">Sets the entity alpha level of an
entity. <br/>
<br/>
The <i>alpha</i> value should be in a floating
point value in the range 0-1. The default entity alpha setting is 1.
<br/>
<br/>
The alpha level is how transparent an entity is. A value
of 1 will mean the entity is opaque. A value of 0 will mean the
entity is completely transparent, i.e. invisible. Values between 0
and 1 will cause varying amount of transparency. This is useful for
imitating the look of objects such as glass and other translucent
materials. <br/>
<br/>
An EntityAlpha value of 0 is especially useful
as OpenB3D will not render entities with such a value, but will still
involve the entities in collision tests. This is unlike HideEntity,
which doesn't involve entities in collisions. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityAutoFade"></a>
<b>void EntityAutoFade(Entity* ent,float near,float far)</b></p>
<p style="margin-bottom: 0cm">Currently not implemented</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityBlend"></a>
<b>void EntityBlend(Entity* ent, int blend)</b></p>
<p><i>Blend</i> - Blend mode of the entity. <br/>
1: Alpha (default)
<br/>
2: Multiply <br/>
3: Add 
</p>
<p><br/>

</p>
<p><b>Description</b></p>
<p>Sets the blending mode of an entity. This blending mode determines
the way in which the new RGBA of the pixel being rendered is combined
with the RGB of the background. <br/>
<br/>
To calculate the new RGBA
of the pixel being rendered, the texture RGBA for the pixel (see
<a href="#TextureBlend">TextureBlend</a> for more information on how
the texture RGBA is calculated) is taken, its alpha component
multiplied by the entities/brushes (where applicable) alpha value and
its color compentent multiplied by the entities/brushes colour. This
is the RGBA which will then be blended into the background pixel, and
how this is done depends on the EntityBlend value. <br/>
<br/>
Alpha:
<br/>
This blends the pixels according to the Alpha value. This is
rougly done to the formula: <br/>
<br/>
Rr = ( An * Rn ) + ( ( 1.0 -
An ) * Ro ) <br/>
Gr = ( An * Gn ) + ( ( 1.0 - An ) * Go ) <br/>
Br =
( An * Bn ) + ( ( 1.0 - An ) * Bo ) <br/>
<br/>
Where R = Red, G =
Green, B = Blue, n = new pixel colour values, r = resultant colour
values, o = old pixel colour values. <br/>
<br/>
Alpha blending is
the default blending mode and is used with most world objects.
<br/>
<br/>
Multiply: <br/>
This blend mode will darken the
underlying pixels. If you think of each RGB value as being on a scale
from 0% to 100%, where 0 = 0% and 255 = 100%, the multiply blend mode
will multiply the red, green and blue values individually together in
order to get the new RGB value, roughly according to: <br/>
<br/>
Rr
= ( ( Rn / 255.0 ) * ( Ro / 255.0 ) ) * 255.0 <br/>
Gr = ( ( Gn /
255.0 ) * ( Go / 255.0 ) ) * 255.0 <br/>
Br = ( ( Bn / 255.0 ) * ( Bo
/ 255.0 ) ) * 255.0 <br/>
<br/>
The alpha value has no effect with
multiplicative blending. Blending a RGB value of 255, 255, 255 will
make no difference, while an RGB value of 128, 128, 128 will darken
the pixels by a factor of 2 and an RGB value of 0, 0, 0 will
completely blacken out the resultant pixels. An RGB value of 0, 255,
255 will remove the red component of the underlying pixel while
leaving the other color values <br/>
untouched. <br/>
<br/>
Multiply
blending is most often used for lightmaps, shadows or anything else
that needs to 'darken' the resultant pixels. <br/>
<br/>
Add:
<br/>
Additive blending will add the new color values to the old,
roughly according to: <br/>
<br/>
Rr = ( Rn * An ) + Ro <br/>
Gr = (
Gn * An ) + Go <br/>
Br = ( Bn * An ) + Bo <br/>
<br/>
The resultant
RGB values are clipped out at 255, meaning that multiple additive
effects can quickly cause visible banding from smooth gradients.
<br/>
<br/>
Additive blending is extremely useful for effects such as
laser shots and fire.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityBox"></a>
<b>void EntityBox(Entity* ent,float x,float y,float z,float
width,float height,float depth)</b></p>
<p style="margin-bottom: 0cm">entity - entity handle#</p>
<p style="margin-bottom: 0cm"><i>x</i> - x position of entity's
collision box</p>
<p style="margin-bottom: 0cm"><i>y</i> - y position of entity's
collision box</p>
<p style="margin-bottom: 0cm"><i>z</i> - z position of entity's
collision box</p>
<p style="margin-bottom: 0cm"><i>width</i> - width of entity's
collision box</p>
<p style="margin-bottom: 0cm"><i>height</i> - height of entity's
collision box</p>
<p style="margin-bottom: 0cm"><i>depth</i> - depth of entity's
collision box</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Sets the dimensions of an entity's
collision box. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityClass"></a>
<b>const char* EntityClass(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the class name of an entity
(Bone, Mesh, Light...)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityCollided"></a>
<b>Entity* EntityCollided(Entity* ent,int type)</b></p>
<p style="margin-bottom: 0cm">Returns the handle of the entity of the
specified <i>type</i> that collided with the specified <i>entity</i>.
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityColor"></a>
<b>void EntityColor(Entity* ent,float red,float green,float blue)</b></p>
<p style="margin-bottom: 0cm">Set the color of an entity. The <i>red</i>,
<i>green</i> and <i>blue</i> value of the color have to be in the
range 0-255; 0,0,0 is black; 255,255,255 is white (default). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityDistance"></a>
<b><span lang="en-US">float EntityDistance(Entity* src_entity,Entity*
</span><span lang="en-US">dest</span><span lang="en-US">_entity)</span></b></p>
<p style="margin-bottom: 0cm">Returns the distance between <i>src_entity</i>
and <i>dest_entity</i>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityFX"></a>
<b>void EntityFX(Entity* entity,int fx)</b></p>
<p style="margin-bottom: 0cm"><i>ent</i><i>ity</i> - entity handle</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>fx</i> -</p>
<p style="margin-bottom: 0cm">0: nothing (default)</p>
<p style="margin-bottom: 0cm">1: full-bright</p>
<p style="margin-bottom: 0cm">2: use vertex colors instead of brush
color</p>
<p style="margin-bottom: 0cm">4: flatshaded</p>
<p style="margin-bottom: 0cm">8: disable fog</p>
<p style="margin-bottom: 0cm">16: disable backface culling</p>
<p style="margin-bottom: 0cm">32: force alpha-blending</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets miscellaneous effects for an
entity.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Flags can be added to combine two or
more effects. For example, specifying a flag of 3 (1+2) will result
in a full-bright and vertex-coloured brush.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Flag 32, to force alpha-blending, must
be used in order to enable vertex alpha (see <a href="#VertexColor">VertexColor</a>).</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityInView"></a>
<b>int EntityInView(Entity* ent,Camera* cam)</b></p>
<p style="margin-bottom: 0cm">Returns true if the specified entity is
visible to the specified <i>camera</i>. <br/>
<br/>
If the entity is
a mesh, its bounding box will be checked for visibility. <br/>
<br/>
For
all other types of entities, only their centre position will be
checked. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityMatrix"></a>
<b>float* EntityMatrix(Entity* entity)</b></p>
<p style="margin-bottom: 0cm">Returns a pointer to the model matrix
of a given entity (if the entity is a camera, by inverting that
matrix its possible to get the view matrix of that camera)</p>
<p style="margin-bottom: 0cm"> 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityName"></a>
<b>const char* EntityName(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the name of an entity. An
entity's name may be set in a modelling program, or manually set
using <a href="#NameEntity">NameEntity</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityOrder"></a>
<b>void EntityOrder(Entity* ent,int order)</b></p>
<p style="margin-bottom: 0.5cm">Sets the drawing order for an entity.</p>
<p>An order value of 0 will mean the entity is drawn normally. A
value greater than 0 will mean that entity is drawn first, behind
everything else. A value less than 0 will mean the entity is drawn
last, in front of everything else.</p>
<p>Setting an entity's order to non-0 also disables z-buffering for
the entity, so should be only used for simple, convex entities like
skyboxes, sprites etc.</p>
<p>EntityOrder affects the specified entity but none of its child
entities, if any exist.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityParent"></a>
<b>void EntityParent(Entity* ent,Entity* parent_ent,bool global)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>ent</i></span><span lang="en-US">
- entity handle</span></p>
<p style="margin-bottom: 0cm"><i>parent</i> - parent entity handle</p>
<p style="margin-bottom: 0cm"><i>global</i> (optional) - true for the
child entity to retain its global position and orientation. Defaults
to true.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Attaches an entity to a parent.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Parent may be 0, in which case the
entity will have no parent. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityPick"></a>
<b>Entity* EntityPick(Entity* ent,float range)</b></p>
<p style="margin-bottom: 0cm">Returns the nearest entity 'ahead' of
the specified entity, within given <i>range</i>. An entity must have
a non-zero <a href="#EntityPickMode">EntityPickMode</a> to be
pickable. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityPickMode"></a>
<b>void EntityPickMode(Entity* ent,int pick_mode,bool obscurer)</b></p>
<p>Make an entity pickable (with <a href="#EntityPick">EntityPick</a>,
<a href="#CameraPick">CameraPick</a> or <a href="#LinePick">LinePick</a>);
</p>
<p><em><i>pick_mode</i></em> is the picking detection method: 
</p>
<p>1: ellipsoid picking (fastest, but not much accurate: you need to
set ellipsoid radius with <em>EntityRadius</em>) 
</p>
<p>2: polygon picking (the most precise, but slower) 
</p>
<p>3: box picking (need to set box size with <em>EntityBox</em>) 
</p>
<p><em>obscurer</em> is an optional parameter: it is used with
<a href="#EntityVisible">EntityVisible</a> to determine just what can
get in the way of the line-of-sight between 2 entities. This allows
some entities to be pickable using the other pick commands, but to be
ignored (i.e. 'transparent') when using <a href="#EntityVisible">EntityVisible</a>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="EntityPitch"></a><span style="font-variant: small-caps"><b>float
EntityPitch(Entity* ent,bool glob</b></span><span style="font-variant: small-caps"><b>al</b></span><span style="font-variant: small-caps"><b>)</b></span>
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the pitch
angle of an entity. </span>The parameter <i>global, </i>if true,
means the pitch angle returned should be relative to 0 rather than a
parent entity's pitch angle. It is false by default. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The pitch angle is also the x angle of
an entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityRadius"></a>
<b>void EntityRadius(Entity* ent,float radius_x,float radius_y)</b></p>
<p style="margin-bottom: 0cm">Sets the radius of an entity's
collision ellipsoid. <br/>
<br/>
An entity radius should be set for
all entities involved in ellipsoidal collisions, which is all source
entities (as collisions are always ellipsoid-to-something), and
whatever destination entities are involved in ellipsoid-to-ellipsoid
collisions (collision method No.1). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>radius_y</i></span><span lang="en-US">
</span><span lang="en-US">is optional, if omitted the value of
</span><span lang="en-US"><i>radius_x</i></span><span lang="en-US">
will be used</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityRoll"></a>
<b>float EntityRoll(Entity* ent,bool global)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">roll</span><span lang="en-US">
angle of an entity. </span>The parameter <i>global, </i>if true,
means the roll angle returned should be relative to 0 rather than a
parent entity's roll angle. It is false by default. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The roll angle is also the z angle of
an entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityScaleX"></a>
<b>float EntityScaleX(Entity* ent,bool glob)</b></p>
<p style="margin-bottom: 0cm">Gets the x scale factor of an entity</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityScaleY"></a>
<b>float EntityScaleY(Entity* ent,bool glob)</b></p>
<p style="margin-bottom: 0cm">Gets the y scale factor of an entity</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityScaleZ"></a>
<b>float EntityScaleZ(Entity* ent,bool glob)</b></p>
<p style="margin-bottom: 0cm">Gets the z scale factor of an entity</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityShininess"></a>
<b>void EntityShininess(Entity* ent,float shininess)</b></p>
<p style="margin-bottom: 0cm">Sets the specular shininess of an
entity. <br/>
<br/>
The <i>shininess</i> value should be a floating
point number in the range 0-1. The default shininess setting is 0.
<br/>
<br/>
Shininess is how much brighter certain areas of an object
will appear to be when a light is shone directly at them. <br/>
<br/>
Setting
a shininess value of 1 for a medium to high poly sphere, combined
with the creation of a light shining in the direction of it, will
give it the appearance of a shiny snooker ball. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityTexture"></a>
<b>void EntityTexture(Entity* ent,Texture* tex,int frame,int index)</b></p>
<p style="margin-bottom: 0cm"><i>entity</i> - entity handle</p>
<p style="margin-bottom: 0cm"><i>texture</i> - texture handle</p>
<p style="margin-bottom: 0cm"><i>frame</i> (optional) - frame of
texture. Defaults to 0.</p>
<p style="margin-bottom: 0cm"><i>index</i> (optional) - index number
of texture. Should be in the range to 0-7. Defaults to 0.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Applies a texture to an entity.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The optional frame parameter specifies
which texture animation frame should be used as the texture.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The optional index parameter specifies
which index number should be assigned to the texture. Index numbers
are used for the purpose of multitexturing. See <a href="#TextureBlend">TextureBlend</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">A little note about multitexturing and
slowdown. Graphics cards support a maximum amount of textures per
object, which can be used with very little, if any, slowdown. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityType"></a>
<b>void EntityType(Entity* entity,int collision_type,int flags)</b></p>
<p style="margin-bottom: 0cm"><i>entity</i> - entity handle</p>
<p style="margin-bottom: 0cm"><i>collision_type</i> - collision type
of entity. Must be in the range 0-99 for standard collision checking.</p>
<p style="margin-bottom: 0cm"><i>flags</i> (optional):</p>
<p style="margin-bottom: 0cm">0: nothing (default)</p>
<p style="margin-bottom: 0cm">1: recursive, to apply collision type
to entity's children. 
</p>
<p style="margin-bottom: 0cm">2: dynamic. Specifies that the
collision must be evaluated dynamically</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the collision type for an entity.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">A collision_type value of 0 indicates
that no collision checking will occur with that entity. A collision
value of 1-99 will mean collision checking will occur. 
</p>
<p style="margin-bottom: 0cm">Flags can be added to combine two or
more effects. For example, specifying a flag of 3 (1+2) will</p>
<p style="margin-bottom: 0cm">result in recursive, dynamic
collisions.</p>
<p style="margin-bottom: 0cm">Dynamic collisions are slower to
evaluate, but work even when the destination entity is moving.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityVisible"></a>
<b>int EntityVisible(Entity* src_ent,Entity* dest_ent)</b></p>
<p style="margin-bottom: 0cm">Returns true if src_entity and
dest_entity can 'see' each other. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityX"></a>
<b>float EntityX(Entity* ent,bool global)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">The X-coordinate of
the entity. <br/>
If the </span><span lang="en-US"><i>global</i></span><span lang="en-US">
flag is set to False then the parent's local coordinate system is
used. <br/>
<br/>
NOTE: If the entity has no parent then local and
global coordinates are the same. <br/>
In this case you can think of
the 3d world as the parent. <br/>
<br/>
Global coordinates refer to
the 3d world. </span><span lang="en-US">OpenB3D</span><span lang="en-US">
uses a left-handed system: <br/>
<br/>
X+ is to the right <br/>
Y+ is
up <br/>
Z+ is forward ( into the screen ) <br/>
<br/>
Every entity
also has its own Local coordinate system. <br/>
<br/>
The global
system never changes. <br/>
But the local system is carried along as
an entity moves and turns. <br/>
<br/>
This same concept is used in
the entity movement commands: <br/>
<br/>
MoveEntity entity, 0,0,1
<br/>
<br/>
No matter what the orientation this moves one unit
forward. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityY"></a>
<b>float EntityY(Entity* ent,bool global)</b></p>
<p style="margin-bottom: 0cm">The Y-coordinate of the entity. <br/>
If
the <i>global</i> flag is set to False then the parent's local
coordinate system is used. <br/>
<br/>
See <a href="#EntityX">EntityX</a>()
for an overview of Local and Global coordinates.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityYaw"></a>
<b>float EntityYaw(Entity* ent,bool glob)</b></p>
<p style="margin-bottom: 0cm">Returns the roll angle of an entity.
The parameter <i>global, </i>if true, means the roll angle returned
should be relative to 0 rather than a parent entity's roll angle. It
is false by default. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The roll angle is also the y angle of
an entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="EntityZ"></a>
<b>float EntityZ(Entity* ent,bool global)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">The </span><span lang="en-US">Z</span><span lang="en-US">-coordinate
of the entity. <br/>
If the </span><span lang="en-US"><i>global</i></span><span lang="en-US">
flag is set to False then the parent's local coordinate system is
used. <br/>
<br/>
See </span><a href="#EntityX">EntityX</a><span lang="en-US">()
for an overview of Local and Global coordinates.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ExtractAnimSeq"></a>
<b>int ExtractAnimSeq(Entity* ent,int first_frame,int last_frame,int
seq)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">On an animated mesh,
it selects only a part of the animation, that is included between
</span><span lang="en-US"><i>first_frame</i></span><span lang="en-US"><span style="font-style: normal">
and </span></span><span lang="en-US"><i>last frame</i></span><span lang="en-US"><span style="font-style: normal">,
and returns the corresponding number, that can be used with the
</span></span><a href="#Animate">Animate</a><span lang="en-US"><span style="font-style: normal">
command. The parameter </span></span><span lang="en-US"><i>seq</i></span><span lang="en-US"><span style="font-style: normal">
specifies the sequence to extract from (if its 0, the sequence is
extracted by the whole animation)</span></span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">T</span></span><span lang="en-US"><span style="font-style: normal">his
command is useful because animated meshes often pack several
different actions in a single sequence (jumping, walking, running,
and so on); this command allows to separate them into different
sequences.</span></span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FindChild"></a>
<b>Entity* FindChild(Entity* ent,char* child_name)</b></p>
<p style="margin-bottom: 0cm">Returns the first child of the
specified entity with name matching <i>child_name</i>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FindSurface"></a>
<b>Surface* FindSurface(Mesh* mesh,Brush* brush)</b></p>
<p style="margin-bottom: 0cm">Currently unsupported</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FitMesh"></a>
<b>void FitMesh(Mesh* mesh,float x,float y,float z,float width,float
height,float depth,bool uniform)</b></p>
<p style="margin-bottom: 0cm"> <i>mesh</i> - mesh handle</p>
<p style="margin-bottom: 0cm"><i>x</i> - x position of mesh</p>
<p style="margin-bottom: 0cm"><i>y</i> - y position of mesh</p>
<p style="margin-bottom: 0cm"><i>z</i> - z position of mesh</p>
<p style="margin-bottom: 0cm"><i>width</i> - width of mesh</p>
<p style="margin-bottom: 0cm"><i>height</i> - height of mesh</p>
<p style="margin-bottom: 0cm"><i>depth</i> - depth of mesh</p>
<p style="margin-bottom: 0cm"><i>uniform</i> (optional) - if true,
the mesh will be scaled  by the same amounts in x, y and z, so will
not be distorted. Defaults to false.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Scales and translates all vertices of a
mesh so that the mesh occupies the specified box.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Do not use a <i>width</i>, <i>height</i>
or <i>depth</i> value of 0, otherwise all mesh data will be destroyed
and your mesh will not be displayed. Use a value of 0.001 instead for
a flat mesh along one axis. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FlipMesh"></a>
<b>void FlipMesh(Mesh* mesh)</b></p>
<p><em>mesh</em> - mesh handle 
</p>
<p>Flips all the triangles in a mesh. 
</p>
<p>This is useful for a couple of reasons. Firstly though, it is
important to understand a little bit of the theory behind 3D
graphics. A 3D triangle is represented by three points; only when
these points are presented to the viewer in a clockwise-fashion is
the triangle visible. So really, triangles only have one side. 
</p>
<p>Normally, for example in the case of a sphere, a model's triangles
face the inside of the model, so it doesn't matter that you can't see
them. However, what about if you wanted to use the sphere as a huge
sky for your world, i.e. so you only needed to see the inside? In
this case you would just use FlipMesh. 
</p>
<p>Another use for FlipMesh is to make objects two-sided, so you can
see them from the inside and outside if you can't already. In this
case, you can copy the original mesh using CopyEntity, specifying the
original mesh as the parent, and flip it using FlipMesh. You will now
have two meshes occupying the same space - this will make it
double-sided, but beware, it will also double the polygon count! 
</p>
<p>The above technique is worth trying when an external modelling
program has exported a model in such a way that some of the triangles
appear to be missing. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FluidArray"></a>
<b>void FluidArray(Fluid* fluid, float* Array, int width, int height,
int depth)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">This is an advanced
function, to </span><span lang="en-US">make an isosurface based on a
custom data set. It accepts a pointer to 3d array, of given </span><span lang="en-US"><i>width</i></span><span lang="en-US">,
</span><span lang="en-US"><i>height</i></span><span lang="en-US"> and
</span><span lang="en-US"><i>depth</i></span><span lang="en-US">. </span><span lang="en-US">The
data set must be of single precision floating-point numbers, and it
will be represented as a box of voxels, that will be visible for
values that are greater than a given threshold (by default 0.5).
Interpolation is used to provide a smoother look.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FluidFunction"></a>
<b>void FluidFunction(Fluid* fluid, float (*FieldFunction)(float,
float, float))</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">This is an advanced
function, to </span><span lang="en-US">make an isosurface based on a
custom </span><span lang="en-US">function</span><span lang="en-US">.
It accepts a pointer to </span><span lang="en-US">a callback
function, that will accept the single precision floating-point
parameters </span><span lang="en-US"><i>x</i></span><span lang="en-US">,
</span><span lang="en-US"><i>y</i></span><span lang="en-US">, and </span><span lang="en-US"><i>z</i></span><span lang="en-US">.
</span><span lang="en-US">The function must return a single precision
floating-point value, that will be calculated according </span><span lang="en-US">to
the given coordinates. The resulting 3d objects </span><span lang="en-US">will
be visible for values that are greater than a given threshold (by
default 0.5).</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FluidThreshold"></a>
<b>void FluidThreshold(Fluid* fluid, float threshold)</b></p>
<p style="margin-bottom: 0cm">Allows to change the threshold of a
fluid object (isosurface). It will affect the behavior of blobs, and
of custom data sets or custom functions.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeAction"></a>
<b>void FreeAction(Action* act, int global)</b></p>
<p style="margin-bottom: 0cm">Terminates an action immediately. When
<i>global</i> is set to <i>false</i>, if the action has any appended
actions, they will start. If the action has not yet been executed
(because it was appended to another action), it will be skipped and
any action scheduled after it will be activated in its place.</p>
<p style="margin-bottom: 0cm">When <i>global</i> is set to <i>true</i>,
any appended action is also terminated.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeBrush"></a>
<b>void  FreeBrush(Brush* brush)</b></p>
<p style="margin-bottom: 0cm">Frees up a brush</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeConstraint"></a>
<b>void FreeConstraint(Constraint* con)</b></p>
<p style="margin-bottom: 0cm">Frees up a constraint</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeEntity"></a>
<b>void FreeEntity(Entity* ent)</b></p>
<center>
	<table width="100%" cellpadding="2" cellspacing="0">
		<col width="256*"/>
		<tr>
			<td width="100%" style="border: none; padding: 0cm"><p>Frees up an
				entity.</p>
			</td>
		</tr>
	</table>
</center>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeRigidBody"></a>
<b>void FreeRigidBody(RigidBody* body)</b></p>
<p style="margin-bottom: 0cm">Frees up a rigid body</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeShadow"></a>
<b>void FreeShadow(ShadowObject* shad)</b></p>
<p style="margin-bottom: 0cm">Frees up a shadow 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="FreeShader"></a><span style="font-variant: small-caps"><span lang="en-US"><b>void
FreeShad</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>er</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>(Shad</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>er</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>*
shad)</b></span></span></p>
<p style="margin-bottom: 0cm">Frees up a shader 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreeTexture"></a>
<b>void FreeTexture(Texture* tex)</b></p>
<p style="margin-bottom: 0cm">Frees up a texture</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="FreePostFX"></a>
<b>void FreePostFX(Texture* tex)</b></p>
<p style="margin-bottom: 0cm">Frees up a post-processing effect</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GeosphereHeight"></a>
<b>void GeosphereHeight(Geosphere* geo, float h)</b></p>
<p style="margin-bottom: 0cm">Sets the maximum height of mountains on
a geosphere terrain</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetBrushTexture"></a>
<b>Texture* GetBrushTexture(Brush* brush,int index)</b></p>
<p style="margin-bottom: 0cm">Returns the texture that is applied to
the specified brush. <br/>
<br/>
The optional <i>index</i> parameter
allows you to specify which particular texture you'd like returning,
if there are more than one textures applied to a brush. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetBone"></a>
<b><span lang="en-US">Bone</span><span lang="en-US">* Get</span><span lang="en-US">Bone</span><span lang="en-US">(Mesh*
mesh,int </span><span lang="en-US">index</span><span lang="en-US">)</span></b></p>
<p style="margin-bottom: 0cm">Returns the handle of the bone attached
to the specified mesh and with the specified index number. <br/>
<br/>
<i>Index</i>
should be in the range 1...CountBones( mesh ), inclusive. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetChild"></a>
<b>Entity* GetChild(Entity* ent,int child_no)</b></p>
<p style="margin-bottom: 0cm">Returns a child of an entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetEntityBrush"></a>
<b>Brush* GetEntityBrush(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns a brush with the same
properties as is applied to the specified entity. <br/>
<br/>
If this
command does not appear to be returning a valid brush, try using
<a href="#GetSurfaceBrush">GetSurfaceBrush</a> instead with the first
surface available. <br/>
<br/>
Remember, GetEntityBrush actually
creates a new brush so don't forget to free it afterwards using
FreeBrush to prevent memory leaks. <br/>
<br/>
Once you have got the
brush handle from an entity, you can use GetBrushTexture and
TextureName to get the details of what texture(s) are applied to the
brush. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetEntityType"></a>
<b>int GetEntityType(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns the collision type of an entity
as set by the EntityType command. <br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetMatElement"></a>
<b>float GetMatElement(Entity* ent,int row,int col)</b></p>
<p style="margin-bottom: 0cm">unsupported</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetParentEntity"></a>
<b>Entity* GetParentEntity(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Returns an entity's parent</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetShaderProgram"></a>
<b>int GetShaderProgram(Shader* material)</b></p>
<p style="margin-bottom: 0cm">Returns the number of the OpenGL
program object, in case you need to access it directly</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetSurface"></a>
<b><span lang="en-US">Surface* GetSurface(Mesh* mesh,int </span><span lang="en-US">index</span><span lang="en-US">)</span></b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the handle
of the surface attached to the specified mesh and with the specified
index number. <br/>
<br/>
</span><span lang="en-US"><i>Index</i></span><span lang="en-US">
should be in the range 1...CountSurfaces( mesh ), inclusive. <br/>
<br/>
You
need to 'get a surface', i.e. get its handle, in order to be able to
then use that particular surface with other commands. <br/>
</span><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="GetSurfaceBrush"></a>
<b>Brush* GetSurfaceBrush(Surface* surf)</b></p>
<p style="margin-bottom: 0cm">Returns a brush with the same
properties as is applied to the specified mesh surface. <br/>
<br/>
If
this command does not appear to be returning a valid brush, try using
<a href="#GetEntityBrush">GetEntityBrush</a> instead. <br/>
<br/>
Remember,
GetSurfaceBrush actually creates a new brush so don't forget to free
it afterwards using <a href="#FreeBrush">FreeBrush</a> to prevent
memory leaks. <br/>
<br/>
Once you have got the brush handle from a
surface, you can use <a href="#GetBrushTexture">GetBrushTexture</a>
and <a href="#TextureName">TextureName</a> to get the details of what
texture(s) are applied to the brush. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="Graphics3D"></a>
<b>void Graphics3D(int width,int height,int depth,int mode,int rate)</b></p>
<p>Initialise the library; this command will set horizontal and
vertical resolution with <em>width</em> and <em>height</em>. Other
parameters (<em>depth</em>, <em>mode</em>, <em>rate</em>) are
optional, and currently unused. 
</p>
<p><strong>ATTENTION</strong>: this command <strong>does not</strong>
create an openGL context (that is, a place where the 3d image is
rendered: it can be the full screen, a window, or a place inside a
window); you'll need to create it manually: in FreeBasic, the
simplest way to do that is with <strong>SCREEN</strong> command: 
</p>
<pre class="western">SCREEN 18, 32, , &amp;h02

Graphics3d 640,480,32,1,1</pre><p>
(the &amp;h02 parameter in SCREEN command specify to use openGL); of
course, SCREENRES, too, can be used: 
</p>
<pre class="western">SCREENRES 640, 480, 32, , &amp;h02  
Graphics3d 640,480,32,1,1</pre><p>
Otherwise, external libraries like GluT can be used, or
system-specific APIs can be called. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="HandleSprite"></a>
<b>void HandleSprite(Sprite* sprite,float h_x,float h_y)</b></p>
<p style="margin-bottom: 0cm">Sets a sprite handle. Defaults to 0,0.
<br/>
<br/>
A sprite extends from -1,-1 to +1,+1.  If it is scaled or
rotated, the handle is the center of rotation</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="HideEntity"></a>
<b>void HideEntity(Entity* ent)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p>Hides an entity, so that it is no longer visible, and is no longer
involved in collisions. Hidden cameras wont be used in rendering.</p>
<p><br/>
The main purpose of hide entity is to allow you to create
entities at the beginning of a program, hide them, then copy them and
show as necessary in the main game. This is more efficient than
creating entities mid-game. <br/>
<br/>
If you wish to hide an entity
so that it is no longer visible but still involved in collisions,
then use EntityAlpha 0 instead. This will make an entity completely
transparent. <br/>
<br/>
HideEntity <span lang="en-US">affects the
specified entity only - child entities are not affected. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LightColor"></a>
<b>void LightColor(Light* light,float red,float green,float blue)</b></p>
<p style="margin-bottom: 0cm">Sets the color of a light. <br/>
<br/>
An
r,g,b value of 255,255,255 will brighten anything the light shines
on. <br/>
<br/>
An r,g,b value of 0,0,0 will have no affect on
anything it shines on. <br/>
<br/>
An r,g,b value of -255,-255,-255
will darken anything it shines on. This is known as 'negative
lighting', and is useful for shadow effects. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="LightConeAngles"></a><span style="font-variant: small-caps"><b>void
LightConeAngles(Light* light,float inner_ang</b></span><span style="font-variant: small-caps"><b>le</b></span><span style="font-variant: small-caps"><b>,float
outer_ang</b></span><span style="font-variant: small-caps"><b>le</b></span><span style="font-variant: small-caps"><b>)</b></span>
</p>
<p style="margin-bottom: 0cm"><i>light</i> - light handle</p>
<p style="margin-bottom: 0cm"><i>inner_angle</i> - inner angle of
cone</p>
<p style="margin-bottom: 0cm"><i>outer_angle </i>- outer angle of
cone</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the 'cone' angle for a 'spot'
light.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The default light cone angles setting
is 0,90. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LightRange"></a>
<b>void LightRange(Light* light,float range)</b></p>
<p style="margin-bottom: 0cm">Sets the range of a light. <br/>
<br/>
The
range of a light is how far it reaches. Everything outside the range
of the light will not be affected by it. <br/>
<br/>
The value is
very approximate, and should be experimented with for best results. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LinePick"></a>
<b>Entity* LinePick(float x,float y,float z,float dx,float dy,float
dz,float radius)</b></p>
<p style="margin-bottom: 0cm"><i>x</i> - x coordinate of start of
line pick</p>
<p style="margin-bottom: 0cm"><i>y</i> - y coordinate of start of
line pick</p>
<p style="margin-bottom: 0cm"><i>z</i> - z coordinate of start of
line pick</p>
<p style="margin-bottom: 0cm"><i>dx</i> - distance x of line pick</p>
<p style="margin-bottom: 0cm"><i>dy</i> - distance y of line pick</p>
<p style="margin-bottom: 0cm"><i>dz</i> - distance z of line pick</p>
<p style="margin-bottom: 0cm"><i>radius</i> (optional) - radius of
line pick</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Returns the first entity between<span style="font-style: normal">
x,y,z to x+d</span>x,y+dy,z+dz.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadAnimMesh"></a>
<b>Mesh* LoadAnimMesh(char* file,Entity* parent)</b></p>
<p style="margin-bottom: 0cm">LoadAnimMesh, similar to LoadMesh,
Loads a mesh from an .X, .3DS, MD2 or .B3D file and returns a mesh
handle. <br/>
<br/>
The difference between <a href="#LoadMesh">LoadMesh</a>
and LoadAnimMesh is that any hierarchy and animation information
present in the file is retained. You can then either activate the
animation by using the Animate command or find child entities within
the hierarchy by using the FindChild(), GetChild() functions.
Animation is available only in .B3D and .MD2 files, not in .3DS or
.X<br/>
<br/>
The optional parent parameter allows you to specify a
parent entity for the mesh so that when the parent is moved the child
mesh will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadAnimSeq"></a>
<b>int LoadAnimSeq(Entity* ent, char* file)</b></p>
<p style="margin-bottom: 0cm">Appends an animation sequence from a
file to an entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadAnimTexture"></a>
<b>Texture* LoadAnimTexture(char* file,int flags,int frame_width,int
frame_height,int first_frame,int frame_count)</b></p>
<p style="margin-bottom: 0cm"><i>file</i> - name of image file with
animation frames laid out in left-right, top-to-bottom order</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>flags</i> (optional) - texture flag:</p>
<p style="margin-bottom: 0cm">1: Color (default)</p>
<p style="margin-bottom: 0cm">2: Alpha</p>
<p style="margin-bottom: 0cm">4: Masked</p>
<p style="margin-bottom: 0cm">8: Mipmapped</p>
<p style="margin-bottom: 0cm">16: Clamp U</p>
<p style="margin-bottom: 0cm">32: Clamp V</p>
<p style="margin-bottom: 0cm">64: Spherical reflection map</p>
<p style="margin-bottom: 0cm">128: Cubic environment map</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>frame_width</i> - width of each
animation frame</p>
<p style="margin-bottom: 0cm"><i>frame_height</i> - height of each
animation frame</p>
<p style="margin-bottom: 0cm"><i>first_frame</i> - the first frame to
be used as an animation frame</p>
<p style="margin-bottom: 0cm"><i>frame_count</i> - the amount of
frames to be used</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Loads an animated texture from an image
file and returns the texture's handle.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The flags parameter allows you to apply
certain effects to the texture. Flags can be added to combine two or
more effects, e.g. 3 (1+2) = texture with colour and alpha maps.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">See <a href="#CreateTexture">CreateTexture</a>
for more detailed descriptions of the texture flags.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">The </span><span lang="en-US"><i>frame_width</i></span><span lang="en-US">,
</span><span lang="en-US"><i>frame_height</i></span><span lang="en-US">,
</span><span lang="en-US"><i>first_frame</i></span><span lang="en-US">
and </span><span lang="en-US"><i>frame_count</i></span><span lang="en-US">
parameters determine how </span><span lang="en-US">OpenB3D</span><span lang="en-US">
will separate the image file into individual animation frames.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="LoadBrush"></a><span style="font-variant: small-caps"><b>Brush*
LoadBrush(char *file,int flags,float u_scale,float v_scale)</b></span>
</p>
<p style="margin-bottom: 0cm"><i>file</i> - filename of texture</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>flags</i> (optional) - flags can be
added to combine effects:</p>
<p style="margin-bottom: 0cm">1: Color</p>
<p style="margin-bottom: 0cm">2: Alpha</p>
<p style="margin-bottom: 0cm">4: Masked</p>
<p style="margin-bottom: 0cm">8: Mipmapped</p>
<p style="margin-bottom: 0cm">16: Clamp U</p>
<p style="margin-bottom: 0cm">32: Clamp V</p>
<p style="margin-bottom: 0cm">64: Spherical reflection map</p>
<p style="margin-bottom: 0cm">128: cube reflection map</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>u_scale</i> - brush u_scale</p>
<p style="margin-bottom: 0cm"><i>v_scale</i> - brush v_scale</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Creates a brush, loads and assigns a
texture to it, and returns a brush handle. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="LoadGeosphere"></a><span style="font-variant: small-caps"><b>Terrain*
LoadGeosphere(char* file,Entity* parent)</b></span> 
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Loads a </span><span lang="en-US">spherical
</span><span lang="en-US">terrain </span><span lang="en-US">(also
called planet, or geosphere) </span><span lang="en-US">from an image
file and returns the terrain's handle. <br/>
<br/>
The image's red
channel is used to determine heights. </span><span lang="en-US">Geosphere</span><span lang="en-US">
is initially the </span><span lang="en-US">same size as the height of</span><span lang="en-US">
the image. <br/>
<br/>
Tips on generating nice terrain: <br/>
<br/>
*
Smooth or blur the height map <br/>
* Reduce the camera range <br/>
<br/>
When
texturing an entity, a texture with a scale of 1,1,1 (default) will
be the same size as one of the terrain's grid squares. A texture that
is scaled to the same size as the </span><span lang="en-US">height</span><span lang="en-US">
of the bitmap used to load it or the no. of grid square used to
create it, will be the same size as the terrain. <br/>
<br/>
The
optional parent parameter allows you to specify a parent entity for
the terrain so that when the parent is moved the child terrain will
move with it. However, this relationship is one way; applying
movement commands to the child will not affect the parent. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">A heightmaps width
must be  twice the height, since equirectangular projection will be
used: each horizontal unit will correspond to one unit of longitude,
each vertical unit will correspond to one unit of latitude. Since
latitude is 180 (from one pole to the other, </span><span lang="en-US">90
north to 90 south</span><span lang="en-US">) and longitude is 360
(equatorial circumference, </span><span lang="en-US">from 180 east
to 180 west</span><span lang="en-US">), </span><span lang="en-US">width
must be twice the height.</span><span lang="en-US"><br/>
</span><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="LoadMaterial"></a><span style="font-variant: small-caps"><b>Material*
LoadMaterial(char* filename,int flags, int frame_width,int
frame_height,int first_frame,int frame_count)</b></span> 
</p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>file</i></span><span lang="en-US">
- name of image file with </span><span lang="en-US">slices </span><span lang="en-US">laid
out in left-right, top-to-bottom order</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>flags</i> (optional) - texture flag:</p>
<p style="margin-bottom: 0cm">1: Color (default)</p>
<p style="margin-bottom: 0cm">2: Alpha</p>
<p style="margin-bottom: 0cm">4: Masked</p>
<p style="margin-bottom: 0cm">8: Mipmapped</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>frame_width</i> - width of each
animation frame</p>
<p style="margin-bottom: 0cm"><i>frame_height</i> - height of each
animation frame</p>
<p style="margin-bottom: 0cm"><i>first_frame</i> - the first frame to
be used as an animation frame</p>
<p style="margin-bottom: 0cm"><i>frame_count</i> - the amount of
frames to be used</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Loads a 3d texture from an image file
and returns the texture's handle.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The flags parameter allows you to apply
certain effects to the texture. Flags can be added to combine two or
more effects, e.g. 3 (1+2) = texture with colour and alpha maps.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">The </span><span lang="en-US"><i>frame_width</i></span><span lang="en-US">,
</span><span lang="en-US"><i>frame_height</i></span><span lang="en-US">,
</span><span lang="en-US"><i>first_frame</i></span><span lang="en-US">
and </span><span lang="en-US"><i>frame_count</i></span><span lang="en-US">
parameters determine how </span><span lang="en-US">OpenB3D</span><span lang="en-US">
will separate the image file into individual animation frames.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadMesh"></a>
<b>Mesh* LoadMesh(char* file,Entity* parent)</b></p>
<p style="margin-bottom: 0cm">LoadMesh, as the name suggests, Loads a
mesh from an .X, .3DS or .B3D file (Usually created in advance by one
of a number of 3D model creation packages) and returns the mesh
handle. <br/>
<br/>
Any hierarchy and animation information in the
file will be ignored. Use <a href="#LoadAnimMesh">LoadAnimMesh</a> to
maintain hierarchy and animation information. <br/>
<br/>
The
optional parent parameter allows you to specify a parent entity for
the mesh so that when the parent is moved the child mesh will move
with it. However, this relationship is one way; applying movement
commands to the child will not affect the parent. <br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadShader"></a>
<b>Shader* LoadShader(char* ShaderName, char* VshaderFileName, char*
FshaderFileName)</b></p>
<p style="margin-bottom: 0cm">Loads a shader. A shader is a special
program that is not run on the CPU, but on the GPU, and its
written in GLSL (GL Shading Language). It requires a name, and two
files, called Vertex Shader and Fragment Shader</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadShaderVGF"></a>
<b>Shader* LoadShaderVGF(char* ShaderName, char* VshaderFileName,
char* GshaderFileName, char* FshaderFileName)</b></p>
<p style="margin-bottom: 0cm">Loads a shader. A shader is a special
program that is not run on the CPU, but on the GPU, and its
written in GLSL (GL Shading Language). It requires a name, and three
files, called Vertex Shader, Geometry Shader and Fragment Shader. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadSprite"></a>
<b>Sprite* LoadSprite(char* tex_file,int tex_flag,Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><i>text_file</i> - filename of image
file to be used as sprite</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>tex_flag</i> (optional) - texture
flag:</p>
<p style="margin-bottom: 0cm">1: Color</p>
<p style="margin-bottom: 0cm">2: Alpha</p>
<p style="margin-bottom: 0cm">4: Masked</p>
<p style="margin-bottom: 0cm">8: Mipmapped</p>
<p style="margin-bottom: 0cm">16: Clamp U</p>
<p style="margin-bottom: 0cm">32: Clamp V</p>
<p style="margin-bottom: 0cm">64: Spherical reflection map</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>parent</i> - parent of entity</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Creates a sprite entity, and assigns a
texture to it. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadTerrain"></a>
<b>Terrain* LoadTerrain(char* file,Entity* parent)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Loads a terrain from
an image file and returns the terrain's handle. <br/>
<br/>
The
image's red channel is used to determine heights. Terrain is
initially the same width and depth as the image, and 1 unit high.
<br/>
<br/>
Tips on generating nice terrain: <br/>
<br/>
* Smooth or
blur the height map <br/>
* Reduce the y scale of the terrain <br/>
*
Increase the x/z scale of the terrain <br/>
* Reduce the camera range
<br/>
<br/>
When texturing an entity, a texture with a scale of 1,1,1
(default) will be the same size as one of the terrain's grid squares.
A texture that is scaled to the same size as the size of the bitmap
used to load it or the no. of grid square used to create it, will be
the same size as the terrain. <br/>
<br/>
The optional parent
parameter allows you to specify a parent entity for the terrain so
that when the parent is moved the child terrain will move with it.
However, this relationship is one way; applying movement commands to
the child will not affect the parent. <br/>
<br/>
Specifying a parent
entity will still result in the terrain being created at position
0,0,0 rather than at the parent entity's position. <br/>
<br/>
A
heightmaps dimensions (width and height) must be the same and </span><span lang="en-US">should</span><span lang="en-US">
be a power of 2, e.g. 32, 64, 128, 256, 512, 1024. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="LoadTexture"></a>
<b>Texture* LoadTexture(char* file,int flags)</b></p>
<p>Load a texture from an image file and returns the texture's
handle. Supported file formats include: BMP, PNG, TGA and JPG. Only
PNG and TGA support alpha. 
</p>
<p>The optional flags parameter allows you to apply certain effects
to the texture. Flags can be added to combine two or more effects,
e.g. 3 (1+2) = texture with colour and alpha maps. 
</p>
<p>See <a href="#CreateTexture">CreateTexture</a> for more detailed
descriptions of the texture flags. 
</p>
<p>Something to consider when applying texture flags to loaded
textures is that the texture may have already had certain flags
applied to it via the <a href="#TextureFilter">TextureFilter</a>
command. The default for the <a href="#TextureFilter">TextureFilter</a>
command is 9 (1+8), which is a coloured, mipmapped texture. This
cannot be overridden via the flags parameter of the LoadTexture
command - if you wish for the filters to be removed you will need to
use the <a href="#ClearTextureFilters">ClearTextureFilters</a>
command, which must be done after setting the graphics mode (setting
the graphics mode restores the default texture filters). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="MeshCSG"></a>
<b>Mesh* MeshCSG(Mesh* m1, Mesh* m2, int method = 1)</b></p>
<p style="margin-bottom: 0cm"><i>m1</i> first mesh</p>
<p style="margin-bottom: 0cm"><i>m2</i> second mesh</p>
<p style="margin-bottom: 0cm"><i>method</i> CSG operation:</p>
<p style="margin-bottom: 0cm">0: subtraction</p>
<p style="margin-bottom: 0cm">1: union</p>
<p style="margin-bottom: 0cm">2: intersection</p>
<p style="margin-bottom: 0cm">3: decal</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Creates a new mesh by performing a CSG
(Constructive Solid Geometry) operation on two given meshes <i>m1</i>
and <i>m2</i>. Those meshes are not modified, and might need to be
removed with FreeEntity at the end of the CSG operations.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">The </span><span lang="en-US"><i>method</i></span><span lang="en-US">
parameter specifies which CSG operation must be performed: a
subtraction removes the second mesh from the first, basically
creating a hole inside m1, shaped like m2; an union combines the two
meshes into one, removing all the superfluous geometry: in that, it
differs from AddMesh, that includes also the intersecting parts of
meshes, that should never be visible anyway </span><span lang="en-US">(</span><span lang="en-US">if
you use this operation to add many boxes and cylinders, then you flip
the result with FlipMesh, you will get a set of corridors/dungeon</span><span lang="en-US">)</span><span lang="en-US">;
an intersection creates a mesh that is made only by the intersecting
parts of </span><span lang="en-US"><i>m1</i></span><span lang="en-US">
and </span><span lang="en-US"><i>m2</i></span><span lang="en-US">
(the intersection of two spheres can be used to produce a lens shaped
mesh, for example); </span><span lang="en-US">a decal produces a
decal mesh, that is basically a very thin mesh that adheres to the
surface of m1, and is delimited by m2: </span><span lang="en-US">by
setting a negative rendering order with </span><a href="#EntityOrder">EntityOrder</a><span lang="en-US">
its possible to render it after m1, so it will always be visible
over it, and it can be useful to apply a different texture or
material to a selected part of a mesh.</span><span lang="en-US"> </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="MeshCullRadius"></a>
<b>void MeshCullRadius(Entity* ent, float radius)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">This command is the
equivalent of </span><span lang="en-US">Blitz</span><span lang="en-US">3D's
MeshCullBox command. </span>
</p>
<p style="margin-bottom: 0cm">It is used to set the radius of a
mesh's 'cull sphere' - if the 'cull sphere' is not inside the viewing
area, the mesh will not be rendered. 
</p>
<p style="margin-bottom: 0cm">A mesh's cull radius is set
automatically, therefore in most cases you will not have to use this
command. 
</p>
<p style="margin-bottom: 0cm">One time you may have to use it is for
animated meshes where the default cull radius may not take into
account all animation positions, resulting in the mesh being wrongly
culled at extreme positions. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="MeshDepth"></a><span style="font-variant: small-caps"><b>float
MeshDepth(Mesh* mesh)</b></span></p>
<p style="margin-bottom: 0cm">Returns the depth of a mesh. This is
calculated by the actual vertex positions and so the scale of the
entity (set by ScaleEntity) will not have an effect on the resultant
depth. Mesh operations, on the other hand, will effect the result. <br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="MeshesIntersect"></a>
<b>int MeshesIntersect(Mesh* mesh1,Mesh* mesh2)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns true if the
specified meshes are currently intersecting. <br/>
<br/>
This is a
fairly slow routine - use with discretion... <br/>
<br/>
This command
is currently the only polygon-&gt;polygon collision checking routine
available in </span><span lang="en-US">OpenB3D</span><span lang="en-US">.
</span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="MeshHeight"></a><span style="font-variant: small-caps"><b>float
MeshHeight(Mesh* mesh)</b></span> 
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">height</span><span lang="en-US">
of a mesh. This is calculated by the actual vertex positions and so
the scale of the entity (set by ScaleEntity) will not have an effect
on the resultant </span><span lang="en-US">height</span><span lang="en-US">.
Mesh operations, on the other hand, will effect the result. <br/>
</span><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="MeshWidth"></a>
<b>float MeshWidth(Mesh* mesh)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">width</span><span lang="en-US">
of a mesh. This is calculated by the actual vertex positions and so
the scale of the entity (set by ScaleEntity) will not have an effect
on the resultant </span><span lang="en-US">width</span><span lang="en-US">.
Mesh operations, on the other hand, will effect the result. <br/>
</span><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ModifyGeosphere"></a>
<b>void ModifyGeosphere(Geosphere* geo, int x, int z, float
new_height)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Sets the height of a
point on a </span><span lang="en-US">geosphere</span><span lang="en-US">.
</span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ModifyTerrain"></a>
<b>void ModifyTerrain(Terrain* terr, int x, int z, float new_height)</b></p>
<p style="margin-bottom: 0cm">Sets the height of a point on a
terrain. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="MoveBone"></a><span style="font-variant: small-caps"><span lang="en-US"><b>int</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>
Move</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>Bone</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>(</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>Bone</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>*
</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>bone</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>,float
x,float y,float z, </b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>int
segments</b></span></span><span style="font-variant: small-caps"><span lang="en-US"><b>=2</b></span></span><span style="font-variant: small-caps"><b>)</b></span></p>
<p style="margin-bottom: 0cm">Attempts to move a bone to a given
position by modifying the orientation of the other bones. Coordinates
<i>x</i>, <i>y</i> and <i>z</i> are relative to the current position
and orientation of its mesh. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Imagine moving your hand to grab
something: to achieve that, you turn your arm and forearm, bending
the joints of your elbow and shoulder; the same is true in a skeletal
based animation (just moving the hand with commands like MoveEntity
or PositionEntity would not move the elbow, and would change the
length of the forearm). While bones could be easily rotated by
commands like TurnEntity or RotateEntity, its not easy to figure
the correct rotation to make the hand reach a chosen position:
calculating the final position of the hand from given angles is
called forward kinematics; the inverse process (calculating the
angles required to move the hand in a wanted position) is called
inverse kinematics.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The command MoveBone does exactly that:
it rotates the joints of a limb to move a specified bone (usually the
end of that limb) to a given position; this is not always possible
(sometimes the destination is just out of reach), so the function
will return <b>true</b> in case of success, <b>false</b> otherwise.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The optional <i>parameter</i> segments
determines how many joints must be computed: in the example of the
hand, the value is usually 2 (the elbow and the shoulder joint); a
higher value is accepted, but in some cases it could lead to
unpredictable effects caused by cumulative rounding errors.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Since animated meshes dont contain
information about limits or degrees of freedom of a joint, some
movements might result in unnatural poses, like knees bent backward.
This can be prevented by starting from an anatomically correct
position, because the algorithm tries to minimize the changes from
the current position.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="MoveEntity"></a>
<b>void MoveEntity(Entity* ent,float x,float y,float z)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Moves an entity
relative to its current position and orientation.<br/>
<br/>
What
this means is that an entity will move in whatever direction it is
facing. So for example if you have an game character is upright when
first loaded into </span><span lang="en-US">OpenB3D</span><span lang="en-US">
and it remains upright (i.e. turns left or right only), then moving
it by a z amount will always see it move forward or backward, moving
it by a y amount will always see it move up or down, and moving it by
an x amount will always see it strafe.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="NameEntity"></a>
<b>void NameEntity(Entity* ent,char* name)</b></p>
<p style="margin-bottom: 0cm">Sets an entity's name. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="OctreeBlock"></a>
<b>void OctreeBlock(OcTree* octree, Mesh* mesh, int level, float X,
float Y, float Z, float Near=0.0, float Far=1000.0, int Solid=1)</b></p>
<p style="margin-bottom: 0cm">Adds a block to an octree, shaped like
a given <i>mesh</i>. The size of the mesh should fit between -1,-1,-1
and 1,1,1.  A block is supposed to be used to set the &quot;bricks&quot;,
to create more complex levels.</p>
<p style="margin-bottom: 0cm"><span lang="en-US">An octree can be
imagined as a cube subdivided in eight smaller cubes, each one
subdivided again. So, the first level will be a 2x2x2=8 </span><span lang="en-US">cubes</span><span lang="en-US">
structure, at the second level it will be a 4x4x4=64 </span><span lang="en-US">cubes</span><span lang="en-US">
structure, and so on . </span><span lang="en-US">If the block </span><span lang="en-US">is
</span><span lang="en-US">a cube made with CreateCube, it will be
scaled to fit that cell size perfectly. Meshes created with the
graphic primitives (CreateSphere, CreateCone, CreateCube and so on)
usually fit between -1,-1,-1 and 1,1,1, so the octree expects a mesh
of that size (a mesh of different size </span><span lang="en-US">c</span><span lang="en-US">an
</span><span lang="en-US">be </span><span lang="en-US">scale</span><span lang="en-US">d</span><span lang="en-US">
using FitMesh</span><span lang="en-US">).</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US">The block is placed
inside the octree, at the chosen </span><span lang="en-US"><i>level</i></span><span lang="en-US"><span style="font-style: normal">
(a higher level means smaller block size, and higher number of
blocks), and at a position that tries to match the given coordinates
</span></span><span lang="en-US"><i>X</i></span><span lang="en-US"><span style="font-style: normal">,
</span></span><span lang="en-US"><i>Y</i></span><span lang="en-US"><span style="font-style: normal">,
</span></span><span lang="en-US"><i>Z</i></span><span lang="en-US"><span style="font-style: normal">
(referred to the octree, not to the world). It will be scaled
automatically. The same mesh could be used as block in more than one
position (for example, a cubic mesh that is supposed to work as a
wall can be used many times to build a complex maze, and it will be
stored in memory only once).</span></span></p>
<p style="font-style: normal; margin-bottom: 0cm">If the mesh is
animated, all the blocks based on it will be animated, too, and this
can be useful to show flags, fans, or any other animated item that
needs to be used more than once.</p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">A
</span></span><span lang="en-US"><span style="font-style: normal">mesh
</span></span><span lang="en-US"><span style="font-style: normal">that
doesnt fit the recommended size </span></span><span lang="en-US"><span style="font-style: normal">will
be rendered anyway, it will just be larger than the octree cell. It
shouldn't cause problem, since the octree cell is virtual, it is not
something visible on the screen, although it might disappear if the
cell is completely out of view (the scene manager, expecting that the
mesh is completely inside the cell, would conclude that the mesh is
not visible and so it would not render it, not knowing that the
overlapping part of the mesh might be still in view)</span></span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">Parameters
</span></span><span lang="en-US"><i>Near</i></span><span lang="en-US"><span style="font-style: normal">
and </span></span><span lang="en-US"><i>Far</i></span><span lang="en-US"><span style="font-style: normal">
are used in case you need a LOD (Level Of Detail) rendering, to
specify a distance range from the camera: any block closer than </span></span><span lang="en-US"><i>Near</i></span><span lang="en-US"><span style="font-style: normal">
wont be rendered. Any block farther </span></span><span lang="en-US"><span style="font-style: normal">than
</span></span><span lang="en-US"><i>Far</i></span><span lang="en-US"><span style="font-style: normal">
will stop the recursive rendering, so blocks smaller than it wont
be rendered. In that way it is possible to render a large block with
a low detail geometry, and when the camera gets closer, the block
would disappear and be replaced by several smaller blocks with more
details.</span></span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">P</span></span><span lang="en-US"><span style="font-style: normal">arameter
</span></span><span lang="en-US"><i>Solid </i></span><span lang="en-US"><span style="font-style: normal">determines
if the geometry of the block is used in picking or collisions: a
value of zero causes the block to be displayed, but to be ignored by
collision system (this is useful for decorative blocks that contain
grass, or curtains, or vines, or for alpha blocks used to create
volumetric fog or water)</span></span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="OctreeMesh"></a>
<b>void OctreeMesh(OcTree* octree, Mesh* mesh, int level, float X,
float Y, float Z, float Near=0.0, float Far=1000.0)</b></p>
<p style="margin-bottom: 0cm">Attaches a <i>mesh</i> to an octree.
The octree will become its parent. The mesh can be used only in one
position, inside the octree, and must be placed and scaled manually
with PositionEntity and ScaleEntity. It will be attached to a node
inside the octree, at the chosen <i>level</i><span style="font-style: normal">
(a higher level means smaller block size, and higher number of
blocks), and at a position that tries to match the given coordinates
</span><i>X</i><span style="font-style: normal">, </span><i>Y</i><span style="font-style: normal">,
</span><i>Z</i><span style="font-style: normal"> (referred to the
octree, not to the world).</span></p>
<p style="margin-bottom: 0cm"><span style="font-style: normal">This
commands allows to use the octree as a scene manager, In </span><span style="font-style: normal">a
complex scene, with thousands or more of meshes, the default scene
manager would be pretty slow, since it checks for each mesh if it is
in view of the camera before rendering it: an octree can be faster,
because it can group several meshes at once: if one section of the
octree is out of view, all the meshes assigned to that section will
be out of view too, and there is no need to check them one by one.</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><span style="font-style: normal">Parameters
</span></span><span lang="en-US"><i>Near</i></span><span lang="en-US"><span style="font-style: normal">
and </span></span><span lang="en-US"><i>Far</i></span><span lang="en-US"><span style="font-style: normal">
are used in case you need a LOD (Level Of Detail) rendering, to
specify a distance range from the camera: any </span></span><span lang="en-US"><span style="font-style: normal">node</span></span><span lang="en-US"><span style="font-style: normal">
closer than </span></span><span lang="en-US"><i>Near</i></span><span lang="en-US"><span style="font-style: normal">
wont be rendered. Any </span></span><span lang="en-US"><span style="font-style: normal">node
</span></span><span lang="en-US"><span style="font-style: normal">farther
</span></span><span lang="en-US"><span style="font-style: normal">than
</span></span><span lang="en-US"><i>Far</i></span><span lang="en-US"><span style="font-style: normal">
will stop the recursive rendering, so blocks smaller than it wont
be rendered. In that way it is possible to render a large block with
a low detail geometry, and when the camera gets closer, the block
would disappear and be replaced by several smaller blocks with more
details.</span></span></p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PaintEntity"></a>
<b>void PaintEntity(Entity* ent,Brush* brush)</b></p>
<table width="643" cellpadding="2" cellspacing="0">
	<col width="639"/>
	<tr>
		<td width="639" style="border: none; padding: 0cm"><p>Paints a
			entity with a brush. <br/>
<br/>
The reason for using PaintEntity
			to apply specific properties to a entity using a brush rather than
			just using EntityTexture, EntityColor, EntityShininess etc, is
			that you can pre-define one brush, and then paint entities over
			and over again using just the one command rather than lots of
			separate ones. 
			</p>
		</td>
	</tr>
</table>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="PaintMesh"></a><span style="font-variant: small-caps"><b>void
PaintMesh(Mesh* mesh,Brush* brush)</b></span></p>
<p style="margin-bottom: 0.5cm">Paints a mesh with a brush.</p>
<p>This has the effect of instantly altering the visible appearance
of the mesh, assuming the brush's properties are different to what
was was applied to the surface before.</p>
<p>The reason for using PaintMesh to apply specific properties to a
mesh using a brush rather than just using EntityTexture, EntityColor,
EntityShininess etc, is that you can pre-define one brush, and then
paint meshes over and over again using just the one command rather
than lots of separate ones.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PaintSurface"></a>
<b>void PaintSurface(Surface* surf,Brush* brush)</b></p>
<p style="margin-bottom: 0cm">Paints a surface with a brush. <br/>
<br/>
This
has the effect of instantly altering the visible appearance of that
particular surface, i.e. section of mesh, assuming the brush's
properties are different to what was applied to the surface before. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ParticleColor"></a>
<b>void ParticleColor(Sprite* sprite, float red, float green, float
blue, float alpha)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">It affects the
fading color of </span><span lang="en-US">particle trails (particles
are sprites with </span><a href="#SpriteRenderMode">SpriteRenderMode</a><span lang="en-US">
set to 3): those particles can leave a trail behind them, and it is
possible to set the fading color of it (setting it to gray, for a red
particle, allows to produce a flame turning to smoke effect)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ParticleVector"></a>
<b>void ParticleVector(Sprite* sprite, float x, float y, float z)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">It affects the
</span><span lang="en-US">direction</span><span lang="en-US"> of
</span><span lang="en-US">particle trails (particles are sprites with
</span><a href="#SpriteRenderMode">SpriteRenderMode</a><span lang="en-US">
set to 3): those particles can leave a trail behind them, and it is
possible to set the </span><span lang="en-US">direction the trail
will move to, even when the particle itself is not moving. This is
useful to simulate a wind effect.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ParticleTrail"></a>
<b>void ParticleTrail(Sprite* sprite,int length)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">It </span><span lang="en-US">sets
the length </span><span lang="en-US">of </span><span lang="en-US">particle
trails (particles are sprites with </span><a href="#SpriteRenderMode">SpriteRenderMode</a><span lang="en-US">
set to 3): those particles can leave a trail behind them.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="PickedEntity"></a><span style="font-variant: small-caps"><b>Entity*
PickedEntity()</b></span></p>
<p style="margin-bottom: 0cm">Returns the entity picked by the
most recently executed Pick command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.
<br/>
<br/>
Returns 0 if no entity was picked. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedNX"></a>
<b>float PickedNX()</b></p>
<p style="margin-bottom: 0cm">Returns the x component of the normal
of the most recently executed Pick command. This might have been
<a href="#CameraPick">CameraPick</a>, <a href="#EntityPick">EntityPick</a>
or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedNY"></a>
<b>float PickedNY()</b></p>
<p style="margin-bottom: 0cm">Returns the y component of the normal
of the most recently executed Pick command. This might have been
<a href="#CameraPick">CameraPick</a>, <a href="#EntityPick">EntityPick</a>
or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedNZ"></a>
<b>float PickedNZ()</b></p>
<p style="margin-bottom: 0cm">Returns the z component of the normal
of the most recently executed Pick command. This might have been
<a href="#CameraPick">CameraPick</a>, <a href="#EntityPick">EntityPick</a>
or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="PickedSurface"></a><span style="font-variant: small-caps"><b>Surface*
PickedSurface()</b></span> 
</p>
<p style="margin-bottom: 0cm">Returns the handle of the surface that
was picked by the most recently executed Pick command. This
might have been <a href="#CameraPick">CameraPick</a>, <a href="#EntityPick">EntityPick</a>
or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedTime"></a>
<b>float PickedTime()</b></p>
<p style="margin-bottom: 0cm">Returns the time taken to calculate the
most recently executed Pick command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedTriangle"></a>
<b>int PickedTriangle()</b></p>
<p style="margin-bottom: 0cm">Returns the index number of the
triangle that was picked by the most recently executed Pick
command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedX"></a>
<b>float PickedX()</b></p>
<p style="margin-bottom: 0cm">Returns the world x coordinate of the
most recently executed Pick command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.<br/>
<br/>
The
coordinate represents the exact point of where something was picked. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedY"></a>
<b>float PickedY()</b></p>
<p style="margin-bottom: 0cm">Returns the world x coordinate of the
most recently executed Pick command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.
<br/>
<br/>
The coordinate represents the exact point of where
something was picked. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PickedZ"></a>
<b>float PickedZ()</b></p>
<p style="margin-bottom: 0cm">Returns the world x coordinate of the
most recently executed Pick command. This might have been <a href="#CameraPick">CameraPick</a>,
<a href="#EntityPick">EntityPick</a> or <a href="#LinePick">LinePick</a>.<br/>
<br/>
The
coordinate represents the exact point of where something was picked. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PointEntity"></a>
<b>void PointEntity(Entity* ent,Entity* target_ent,float roll)</b></p>
<table width="643" cellpadding="2" cellspacing="0">
	<col width="639"/>
	<tr>
		<td width="639" style="border: none; padding: 0cm"><p>Points one
			entity at another. <br/>
<br/>
The optional <i>roll</i> parameter
			allows you to specify a roll angle as pointing an entity only sets
			pitch and yaw angles. <br/>
<br/>
If you wish for an entity to
			point at a certain position rather than another entity, simply
			create a pivot entity at your desired position, point the entity
			at this and then free the pivot. 
			</p>
		</td>
	</tr>
</table>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PositionBone"></a>
<b>void PositionBone(Bone* bone,float x,float y,float z)</b></p>
<p style="margin-bottom: 0cm">Set the position of a bone, related to
its parent. It doesnt deform the vertices of the mesh, so its
useful to set the starting position of a bone.</p>
<p style="margin-bottom: 0cm">This command is supposed to be used
immediately after the creation of the bone, because it doesnt
update the children entities of the bone.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PositionEntity"></a>
<b>void PositionEntity(Entity* ent,float x,float y,float z,bool
global)</b></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<table width="643" cellpadding="2" cellspacing="0">
	<col width="639"/>
	<tr>
		<td width="639" style="border: none; padding: 0cm"><p>Positions an
			entity at an absolute position in 3D space. <br/>
<br/>
Entities
			are positioned using an <i>x</i>,<i>y</i>,<i>z</i> coordinate
			system. x, y and z each have their own axis, and each axis has its
			own set of values. By specifying a value for each axis, you can
			position an entity anywhere in 3D space. 0,0,0 is the centre of 3D
			space, and if the camera is pointing in the default positive z
			direction, then positioning an entity with a z value of above 0
			will make it appear in front of the camera, whereas a negative z
			value would see it disappear behind the camera. Changing the x
			value would see it moving sideways, and changing the y value would
			see it moving up/down. <br/>
<br/>
Of course, the direction in
			which entities appear to move is relative to the position and
			orientation of the camera. 
			</p>
		</td>
	</tr>
</table>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span style="font-style: normal">The
optional parameter </span><i>global</i><span style="font-style: normal">,</span><i>
</i>if true states that the position should be relative to 0,0,0
rather than a parent entity's position. False by default. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PositionMesh"></a>
<b>void PositionMesh(Mesh* mesh,float px,float py,float pz)</b></p>
<p style="margin-bottom: 0cm">Moves all vertices of a mesh</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PositionTexture"></a>
<b>void PositionTexture(Texture* tex,float u_pos,float v_pos)</b></p>
<p style="margin-bottom: 0cm">Positions a texture at an absolute
position. <br/>
<br/>
This will have an immediate effect on all
instances of the texture being used. <br/>
<br/>
Positioning a
texture is useful for performing scrolling texture effects, such as
for water etc. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PostFXBuffer"></a>
<b>void PostFXBuffer(PostFX* fx, int pass_no, int source_pass, int
index, int slot)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Attaches the output
buffer generated by one pass,</span><span lang="en-US"> </span><span lang="en-US">in
a post processing effect </span><span lang="en-US"><i>fx</i></span><span lang="en-US"><span style="font-style: normal">,
</span></span><span lang="en-US"><span style="font-style: normal">to
be used as input for another step</span></span><span lang="en-US">:
it allows to </span><span lang="en-US">use one of the </span><span lang="en-US">color
buffers (those buffer contain the rendered image), </span><span lang="en-US">or
the </span><span lang="en-US">depth buffer </span><span lang="en-US">as
texture attached to a shader (shaders can use textures as input, so
images must be passed to them as textures)</span><span lang="en-US">.
The </span><span lang="en-US">output buffer create</span><span lang="en-US">d</span><span lang="en-US">
by the stage </span><span lang="en-US"><i>source_pass</i></span><span lang="en-US">
(stage 0 is the scene rendering, stage 1 is the first shader, an</span><span lang="en-US"><span style="font-style: normal">d
so on</span></span><span lang="en-US">) </span><span lang="en-US">will
be used as input </span><span lang="en-US">texture </span><span lang="en-US">for
the </span><span lang="en-US">shader in </span><span lang="en-US">stage
</span><span lang="en-US"><i>pass_no</i></span><span lang="en-US"> </span><span lang="en-US">(0
is the first shader, 1 is the second shader, and so on): </span><span lang="en-US">for
example, a source_pass =0 and a pass_no = 0 mean to use the output of
the scene rendering as input for the first shader; values of 1 and 1
mean to use the output of the first shader as input for the second
one</span><span lang="en-US">. </span>
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">The parameter </span><span lang="en-US"><i>index</i></span><span lang="en-US">
sets </span><span lang="en-US">which texture should be used: 0 is the
depth buffer, 1 or more identifies a </span><span lang="en-US">color
buffer (this is useful when using a shader than outputs different
information on different buffers: for example, in deferred shading
one buffer can contain the normal data, another the actual colors)</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US">T</span><span lang="en-US">he
parameter </span><span lang="en-US"><i>slot</i></span><span lang="en-US">
sets the texture slot to be used, for the shader to identify it.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PostFXFunction"></a>
<b>void PostFXFunction(PostFX* fx, int pass_no, void
(*PassFunction)(void))</b></p>
<p style="margin-bottom: 0cm">Attaches a custom function to a post
processing effect <i>fx</i><span style="font-style: normal">, </span><span style="font-style: normal">to
be executed at step </span><i>pass_no</i><span style="font-style: normal">,
to apply custom post-processing.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PostFXShader"></a>
<b>void PostFXShader(PostFX* fx, int pass_no, Shader* shader)</b></p>
<p style="margin-bottom: 0cm">Attaches a shader program (created with
<a href="#CreateShader">CreateShader</a> or loaded with <a href="#LoadShader">LoadShader</a>)
to the post processing effect <i>fx</i>. The parameter <i>pass_no</i>
specifies at which step the shader will be used (0 is the first one)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PostFXShaderPass"></a>
<b>void PostFXShaderPass(PostFX* fx, int pass_no, char* name, int v)</b></p>
<p style="margin-bottom: 0cm">Passes the numeric parameter <i>v</i>
to the shader attached to the post processing effect <i>fx</i><span style="font-style: normal">
</span><span style="font-style: normal">at the step identified by
</span><i>pass_no</i><span style="font-style: normal">. The string
</span><i>name</i><span style="font-style: normal"> identifies the
uniform used internally by the shader. </span><span style="font-style: normal">This
command is useful when the same shader is used in more steps of the
post-processing</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="PostFXTexture"></a>
<b>void PostFXTexture(PostFX* fx, int pass_no, Texture* tex, int
slot, int frame=0)</b></p>
<p style="margin-bottom: 0cm">Attaches a texture <i>tex</i> to a
pass, in a post processing effect <i>fx</i><span style="font-style: normal">,
</span><span style="font-style: normal">to be used as input.  </span><span style="font-style: normal">It
</span><span style="font-style: normal">will be used as input </span><span style="font-style: normal">texture
</span><span style="font-style: normal">for the </span><span style="font-style: normal">shader
in </span><span style="font-style: normal">stage </span><i>pass_no</i><span style="font-style: normal">
</span><span style="font-style: normal">(0 is the first shader, 1 is
the second shader, and so on).</span></p>
<p style="margin-bottom: 0cm"><span style="font-style: normal">P</span><span style="font-style: normal">assing
a texture is useful to simulate vignetting, or to add a mask to
the picture.</span></p>
<p style="margin-bottom: 0cm"><span style="font-style: normal">T</span><span style="font-style: normal">he
parameter </span><i>slot</i><span style="font-style: normal"> sets
the texture slot to be used, for the shader to identify it.</span></p>
<p style="margin-bottom: 0cm"><span style="font-style: normal">The
parameter </span><i>frame</i><span style="font-style: normal"> is
used to select the frame in animated textures.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ProjectedX"></a>
<b>float ProjectedX()</b></p>
<p>Returns the viewport x coordinate of the most recently executed
<a href="#CameraProject">CameraProject</a>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ProjectedY"></a>
<b>float ProjectedY()</b></p>
<p>Returns the viewport y coordinate of the most recently executed
<a href="#CameraProject">CameraProject</a>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ProjectedZ"></a>
<b>float ProjectedZ()</b></p>
<p>Returns the viewport z coordinate of the most recently executed
<a href="#CameraProject">CameraProject</a>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RenderWorld"></a>
<b>void RenderWorld()</b></p>
<p style="margin-bottom: 0cm">Renders the current scene to the
BackBuffer onto the rectangle defined by each cameras <a href="#CameraViewport">CameraViewport</a>.
Every camera not hidden by <a href="#HideEntity">HideEntity</a> or
with a <a href="#CameraProjMode">CameraProjMode</a> of 0 is rendered.
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RepeatMesh"></a>
<b>Mesh* RepeatMesh(Mesh* mesh,Entity* parent)</b></p>
<p style="margin-bottom: 0cm">Creates an instance of a given mesh:
the instance is a copy of the mesh that does not duplicate all its
data, but uses the same data from the original: in this way, it will
need less memory, but changes made to the original mesh (like
ScaleMesh or RotateMesh) will affect the duplicate as well.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">In case of animated meshes, all the
frames of the mesh will be rendered in memory as separate surface,
and they will be used for the animation: as result, the animation
will be less smooth, and it wont be possible to animate bones
manually; on the other hand, it will be possible to render hundreds
or thousands of animated meshes at different stages of the animation
with less significant impact on speed and memory usage.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p>The optional <i>parent</i> parameter allow you to specify a parent
entity for the camera so that when the parent is moved the child
camera will move with it. However, this relationship is one way;
applying movement commands to the child will not affect the parent.</p>
<p><br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ResetEntity"></a>
<b>void ResetEntity(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Resets the collision state of an
entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ResetShadow"></a>
<b>void ResetShadow(ShadowObject* shad)</b></p>
<p style="margin-bottom: 0cm">Forces a static shadow (created with
the static flag) to be recalculated (useful when the mesh is moved or
deformed). Not needed for dynamic shadows.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RotateBone"></a>
<b>void RotateBone(Bone* bone,float pitch,float yaw,float roll)</b></p>
<p style="margin-bottom: 0cm">Set the rotation of a bone, related to
its parent. It doesnt deform the vertices of the mesh, so its
useful to set the starting rotation of a bone.</p>
<p style="margin-bottom: 0cm">This command is supposed to be used
immediately after the creation of the bone, because it doesnt
update the children entities of the bone.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RotateEntity"></a>
<b>void RotateEntity(Entity* ent,float pitch,float yaw,float
roll,bool global)</b></p>
<p style="margin-bottom: 0cm">entity - name of the entity to be
rotated</p>
<p style="margin-bottom: 0cm"><i>pitch</i> - angle in degrees of
pitch rotation</p>
<p style="margin-bottom: 0cm"><i>yaw</i> - angle in degrees of yaw
rotation</p>
<p style="margin-bottom: 0cm"><i>roll</i> - angle in degrees of roll
rotation</p>
<p style="margin-bottom: 0cm"><i>global</i> (optional) - true if the
angle rotated should be relative to 0,0,0 rather than a parent
entity's orientation. False by default.</p>
<p style="font-style: normal; margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Rotates an entity so that it is at an
absolute orientation.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Pitch</i> is the same as the x angle
of an entity, and is equivalent to tilting forward/backwards.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Yaw</i> is the same as the y angle
of an entity, and is equivalent to turning left/right.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Roll</i> is the same as the z angle
of an entity, and is equivalent to tilting left/right.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RotateMesh"></a>
<b>void RotateMesh(Mesh* mesh,float pitch,float yaw,float roll)</b></p>
<p style="margin-bottom: 0cm">Rotates all vertices of a mesh by the
specified rotation. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RotateSprite"></a>
<b>void RotateSprite(Sprite* sprite,float ang)</b></p>
<p style="margin-bottom: 0cm">Rotates a sprite</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="RotateTexture"></a>
<b>void RotateTexture(Texture* tex,float ang)</b></p>
<p style="margin-bottom: 0cm">Rotates a texture. <br/>
<br/>
This
will have an immediate effect on all instances of the texture being
used. <br/>
<br/>
Rotating a texture is useful for performing
swirling texture effects, such as for smoke etc. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ScaleEntity"></a>
<b>void ScaleEntity(Entity* ent,float x,float y,float z,bool glob)</b></p>
<p style="margin-bottom: 0cm">Scales an entity so that it is of an
absolute size. <br/>
<br/>
Scale values of 1,1,1 are the default size
when creating/loading entities. <br/>
<br/>
Scale values of 2,2,2
will double the size of an entity. <br/>
<br/>
Scale values of 0,0,0
will make an entity disappear. <br/>
<br/>
Scale values of less than
0,0,0 will invert an entity and make it bigger. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ScaleMesh"></a>
<b>void ScaleMesh(Mesh* mesh,float sx,float sy,float sz)</b></p>
<p style="margin-bottom: 0cm">Scales all vertices of a mesh by the
specified scaling factors. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ScaleSprite"></a>
<b>void ScaleSprite(Sprite* sprite,float s_x,float s_y)</b></p>
<p style="margin-bottom: 0cm">Scales a sprite</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ScaleTexture"></a>
<b>void ScaleTexture(Texture* tex,float u_scale,float v_scale)</b></p>
<p style="margin-bottom: 0cm">Scales a texture by an absolute amount.
<br/>
<br/>
This will have an immediate effect on all instances of
the texture being used. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetAnimKey"></a>
<b>void SetAnimKey(Entity* ent, float frame, int pos_key=true, int
rot_key=true, int scale_key=true)</b></p>
<p style="margin-bottom: 0cm"><i>entity</i> - entity handle</p>
<p style="margin-bottom: 0cm"><i>frame</i> - frame of animation to be
used as anim key</p>
<p style="margin-bottom: 0cm"><i>pos_key</i> (optional) - true to
include entity position information when setting key. Defaults to
true.</p>
<p style="margin-bottom: 0cm"><i>rot_key</i> (optional) - true to
include entity rotation information when setting key. Defaults to
true.</p>
<p style="margin-bottom: 0cm"><i>scale_key</i> (optional) - true to
include entity scale information when setting key. Defaults to true.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets an animation key for the specified
entity at the specified frame. The entity must have a valid animation
sequence to work with.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This is most useful when you've got a
character, or a complete set of complicated moves to perform, and you
want to perform them en-masse. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetAnimTime"></a>
<b>void SetAnimTime(Entity* ent,float time,int seq)</b></p>
<p style="margin-bottom: 0cm"><i>entity</i> - a valid entity handle.</p>
<p style="margin-bottom: 0cm"><i>time</i> - a floating point time
value.</p>
<p style="margin-bottom: 0cm"><i>anim_seq</i> - an optional animation
sequence number.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">SetAnimTime allows you to manually
animate entities. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetCubeFace"></a>
<b>void SetCubeFace(Texture* tex,int face)</b></p>
<p style="margin-bottom: 0cm"><i>texture</i> - texture <br/>
<i>face</i>
- face of cube to select. This should be one of the following values:
<br/>
0: left (negative X) face <br/>
1: forward (positive Z) face -
this is the default. <br/>
2: right (positive X) face <br/>
3:
backward (negative Z) face <br/>
4: up (positive Y) face <br/>
5:
down (negative Y) face 
</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Selects a cube face
for direct rendering to a texture. <br/>
<br/>
This command should
only be used when you wish to draw directly to a cube map texture in
real-time. Otherwise, just loading a pre-rendered cube map with a
flag of 128 will suffice. <br/>
<br/>
To understand how this command
works exactly it is important to recognise that </span><span lang="en-US">OpenB3D</span><span lang="en-US">
treats cubemap textures slightly differently to how it treats other
textures. Here's how it works... <br/>
<br/>
A cubemap texture in
</span><span lang="en-US">OpenB3D</span><span lang="en-US"> actually
consists of six images, each of which corresponds to a particular
cube face. These images are stored internally by </span><span lang="en-US">OpenB3D</span><span lang="en-US">,
and the texture handle that is returned by LoadTexture/CreateTexture
when specifying the cube map flag, only provides access to one of
these six images at once (by default the first one, or '0' face).
<br/>
<br/>
This is why, when loading a cubemap texture into </span><span lang="en-US">OpenB3D</span><span lang="en-US">
using LoadTexture, all the six cube map images must be laid out in a
specific order (0-5, as described above), in a horizontal strip. Then
</span><span lang="en-US">OpenB3D</span><span lang="en-US"> takes
this texture and internally converts it into six separate images. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">So seeing as the
texture handle returned by CreateTexture / LoadTexture only provides
access to one of these images at once (no. 1 by default), how do we
get access to the other five images? This is where SetCubeFace comes
in. It will tell </span><span lang="en-US">OpenB3D</span><span lang="en-US">
that whenever you next draw to a cubemap texture, to draw to the
particular image representing the face you have specified with the
face parameter.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Now you have the
ability to draw to a cube map in real-time, </span><span lang="en-US">using
either BufferToTex, BackBufferToTex, or CameraToTex</span><span lang="en-US"><br/>
</span><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetCubeMode"></a>
<b>void SetCubeMode(Texture* tex,int mode)</b></p>
<p style="margin-bottom: 0cm">Set the rendering mode of a cubemap
texture.<br/>
<br/>
The available rendering modes are as follows:<br/>
<br/>
1:
Specular (default). Use this to give your cubemapped objects a shiny
effect.<br/>
<br/>
2: Diffuse. Use this to give your cubemapped
objects a non-shiny, realistic lighting effect.<br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetFloat"></a>
<b>void SetFloat(Shader* material, char* name, float v1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a float parameter to be used inside a shader, where it will be
accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetFloat2"></a>
<b>void SetFloat2(Shader* material, char* name, float v1, float v2)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a float vector with 2 elements to be used inside a shader, where it
will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetFloat3"></a>
<b>void SetFloat3(Shader* material, char* name, float v1, float v2,
float v3)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a float vector with 3 elements to be used inside a shader, where it
will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"> 
</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetFloat4"></a>
<b>void SetFloat4(Shader* material, char* name, float v1, float v2,
float v3, float v4)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a float vector with 4 elements to be used inside a shader, where it
will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetInteger"></a>
<b>void SetInteger(Shader* material, char* name, int v1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
</span><span lang="en-US">an integer </span><span lang="en-US">parameter
to be used inside a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetInteger2"></a>
<b>void SetInteger2(Shader* material, char* name, int v1, int v2)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a</span><span lang="en-US">n integer</span><span lang="en-US"> vector
with 2 elements to be used inside a shader, where it will be
accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetInteger3"></a>
<b>void SetInteger3(Shader* material, char* name, int v1, int v2, int
v3)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a</span><span lang="en-US">n integer </span><span lang="en-US">vector
with </span><span lang="en-US">3</span><span lang="en-US"> elements
to be used inside a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SetInteger4"></a>
<b>void SetInteger4(Shader* material, char* name, int v1, int v2, int
v3, int v4)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Set</span><span lang="en-US">s</span><span lang="en-US">
a</span><span lang="en-US">n integer </span><span lang="en-US">vector
with </span><span lang="en-US">4</span><span lang="en-US"> elements
to be used inside a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShadeEntity"></a>
<b>void ShadeEntity(Entity* ent, Shader* material)</b></p>
<p style="margin-bottom: 0cm">Applies a shader to an entity. A shader
can be seen as a more advanced form of brush, that allows to render
an object using a custom program</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShadeMesh"></a>
<b>void ShadeMesh(Mesh* mesh, Shader* material)</b></p>
<p style="margin-bottom: 0cm">Applies a shader to a mesh, affecting
all its surfaces. A shader can be seen as a more advanced form of
brush, that allows to render an object using a custom program</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShadeSurface"></a>
<b>void ShadeSurface(Surface* surf, Shader* material)</b></p>
<p style="margin-bottom: 0cm">Applies a shader to a surface. A shader
can be seen as a more advanced form of brush, that allows to render
an object using a custom program</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShaderFunction"></a>
<b>void ShaderFunction(Shader* material, void
(*EnableFunction)(void), void (*DisableFunction)(void))</b></p>
<p style="margin-bottom: 0cm">Sets callback functions that are
executed when a shader is used. The first one <i>EnableFunction</i>
is executed when the shader is enabled, the second one
<i>DisableFunction</i> is executed when the shader is disabled.</p>
<p style="margin-bottom: 0cm">It can be used to enable specific
OpenGL parameters, for example glPolygonStipple (an old way to render
transparency without using alpha blending); of course they need to be
disable when the shader is disabled.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShaderMaterial"></a>
<b>void ShaderMaterial(Shader* material, Material* tex, char* name,
int index)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Attaches a </span><span lang="en-US">3d
</span><span lang="en-US">texture to a shader. Up to 255 textures can
be attached. The </span><span lang="en-US"><i>name</i></span><span lang="en-US">
parameter allows the texture to be retrieved inside the shader
program, using the same name. The </span><span lang="en-US"><i>index</i></span><span lang="en-US">
parameter </span><span lang="en-US">sets to which slot the texture
must be attached (never use the same slot for more than one texture
in the same shader)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShaderTexture"></a>
<b>void ShaderTexture(Shader* material, Texture* tex, char* name, int
index)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Attaches a texture
to a shader. Up to 255 textures can be attached. The </span><span lang="en-US"><i>name</i></span><span lang="en-US">
parameter allows the texture to be retrieved inside the shader
program, using the same name. The </span><span lang="en-US"><i>index</i></span><span lang="en-US">
parameter </span><span lang="en-US">sets to which slot the texture
must be attached (never use the same slot for more than one texture
in the same shader)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="ShowEntity"></a>
<b>void ShowEntity(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Shows an entity. Very much the opposite
of <a href="#HideEntity">HideEntity</a>. <br/>
<br/>
Once an entity
has been hidden using HideEntity, use show entity to make it visible
and involved in collisions again. Note that ShowEntity has no effect
if the enitities parent object is hidden. <br/>
<br/>
Entities are
shown by default after creating/loading them, so you should only need
to use ShowEntity after using HideEntity. <br/>
<br/>
ShowEntity
affects the specified entity only - child entities are not affected. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SkinMesh"></a>
<b>void SkinMesh(Mesh* mesh, int surf_no, int vid, int bone1, float
weight1=1.0, int bone2=0, float weight2=0, int bone3=0, float
weight3=0, int bone4=0, float weight4=0)</b></p>
<p style="margin-bottom: 0cm"><i>mesh</i> - mesh</p>
<p style="margin-bottom: 0cm"><i>surf_no</i><span style="font-style: normal">
 the number of the surface inside the mesh (not the surface
handle)</span></p>
<p style="margin-bottom: 0cm"><i>vid</i><span style="font-style: normal">
 number of the vertex inside the surface</span></p>
<p style="margin-bottom: 0cm"><i>bone1</i><span style="font-style: normal">
 the bone number (not the bone handle) of the first bone affecting
the vertex, or 0</span></p>
<p style="margin-bottom: 0cm"><i>weight1</i><span style="font-style: normal">
 how much bone1 affects the vertex deformation</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>bone2</i></span><span lang="en-US"><span style="font-style: normal">
 the bone number (not the bone handle) of the second bone
affecting the vertex, or 0</span></span></p>
<p style="margin-bottom: 0cm"><i>weight2</i><span style="font-style: normal">
 how much bone2 affects the vertex deformation</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>bone3</i></span><span lang="en-US"><span style="font-style: normal">
 the bone number (not the bone handle) of the third bone affecting
the vertex, or 0</span></span></p>
<p style="margin-bottom: 0cm"><i>weight3</i><span style="font-style: normal">
 how much bone3 affects the vertex deformation</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>bone4 </i></span><span lang="en-US"><span style="font-style: normal">
the bone number (not the bone handle) of the fourth bone affecting
the vertex, or 0</span></span></p>
<p style="margin-bottom: 0cm"><i>weight4</i><span style="font-style: normal">
 how much bone4 affects the vertex deformation</span></p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Manually binds a vertex from a mesh to
its bones, for skeletal animation. It can be used to build a loader
for animated mesh from different format, or for procedural generation
of animations.</p>
<p style="margin-bottom: 0cm"><span lang="en-US">E</span><span lang="en-US">ach
bone will have a consecutive number, depending on the order they have
been created with CreateBone (the first bone created will be number
1)</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SpriteRenderMode"></a>
<b>void SpriteRenderMode(Sprite* sprite,int mode)</b></p>
<p style="margin-bottom: 0cm">Sets how sprites are rendered:</p>
<p style="margin-bottom: 0cm">1: default. Each sprite is an
independent surface. It is the simplest rendering method, but also
the slowest</p>
<p style="margin-bottom: 0cm">2: batch sprites. If there are several
identical sprites is is more efficient to combine all visible ones
into a single surface and render it at once. Functionally, batch
sprites are manipulated exactly like default ones</p>
<p style="margin-bottom: 0cm">3: particles. This mode is generally
the fastest one, although it might not be supported on some older
versions of OpenGL. Particle sprites lack some functions (mainly
scaling and rotation) but on the other hand they support trails</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="SpriteViewMode"></a>
<b>void SpriteViewMode(Sprite* sprite,int mode)</b></p>
<p style="margin-bottom: 0cm"><i>sprite</i> - sprite handle</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>view_mode</i> - view_mode of sprite</p>
<p style="margin-bottom: 0cm">1: fixed (sprite always faces camera -
default)</p>
<p style="margin-bottom: 0cm">2: free (sprite is independent of
camera)</p>
<p style="margin-bottom: 0cm">3: upright1 (sprite always faces
camera, but rolls with camera as well, unlike mode no.1)</p>
<p style="margin-bottom: 0cm">4: upright2 (sprite always remains
upright. Gives a 'billboard' effect. Good for trees, spectators etc.)</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the view mode of a sprite.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The view mode determines how a sprite
alters its orientation in respect to the camera. This allows the
sprite to in some instances give the impression that it is more than
two dimensional.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">In technical terms, the four sprite
modes perform the following changes:</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">1: Sprite changes its pitch and yaw
values to face camera, but doesn't roll.</p>
<p style="margin-bottom: 0cm">2: Sprite does not change either its
pitch, yaw or roll values.</p>
<p style="margin-bottom: 0cm">3: Sprite changes its yaw and pitch to
face camera, and changes its roll value to match cameras.</p>
<p style="margin-bottom: 0cm">4: Sprite changes its yaw value to face
camera, but not its pitch value, and changes its roll value to match
cameras.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Note that if you use sprite view mode
2, then because it is independent from the camera, you will only be
able to see it from one side unless you use EntityFx flag 16 with it
to disable backface culling.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="StencilAlpha"></a>
<b>void StencilAlpha(Stencil* stencil, float a)</b></p>
<p style="margin-bottom: 0cm">Sets the alpha level of a stencil clear
operation: a lower value allows to preserve the older background</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="StencilClsColor"></a>
<b>void StencilClsColor(Stencil* stencil, float r,float g,float b)</b></p>
<p style="margin-bottom: 0cm">Sets the color to use to clear the area
affected by a stencil, when it is activated</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="StencilClsMode"></a>
<b>void StencilClsMode(Stencil* stencil,int cls_depth,int
cls_zbuffer)</b></p>
<p style="margin-bottom: 0cm">Every time a stencil is activated the
area affected by it is usually deleted (color buffer and z-buffer are
erased). Setting flags to 0 will keep the old data (it could be
useful to achieve some strange effects, or to combine two or more
renderings in one) 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="StencilMesh"></a>
<b>void StencilMesh(Stencil* stencil, Mesh* mesh, int mode=1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns a mesh to a
stencil, to be used to define the stencil shape. More meshes can be
assigned to the same stencil. Meshes assigned to stencils cannot have
parent entities, and cannot be rendered with RenderWorld. They are
rendered with the command </span><a href="#UseStencil">UseStencil</a><span lang="en-US">,
</span><span lang="en-US">and they affect only the stencil buffer.
The parameter </span><span lang="en-US"><i>mode</i></span><span lang="en-US">
states how the stencil buffer is affected: </span>
</p>
<p style="margin-bottom: 0cm">1: stencil buffer is increased in the
area where the mesh is rendered (the stencil will look like a hole
shaped like the mesh)</p>
<p style="margin-bottom: 0cm">-1:  stencil buffer is decreased in the
area where the mesh is rendered</p>
<p style="margin-bottom: 0cm">2: stencil buffer is increased where
the front face of the mesh are rendered, and decreased where the back
faces are rendered. As result, the mesh wont affect the stencil
buffer, but the intersections between the mesh and regular 3d objects
in the scene will.</p>
<p style="margin-bottom: 0cm">-2 stencil buffer is decreased where
the front face of the mesh are rendered, and increased where the back
faces are rendered</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="StencilMode"></a>
<b><span lang="en-US">void StencilMode(Stencil* stencil, int m</span><span lang="en-US">ode</span><span lang="en-US">,
int o</span><span lang="en-US">perator=1</span><span lang="en-US">)</span></b></p>
<p style="margin-bottom: 0cm"><i>stencil</i>: the stencil</p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>mode</i></span><span lang="en-US">:
the value the stencil level will be compared to</span></p>
<p style="margin-bottom: 0cm"><span lang="en-US"><i>operator</i></span><span lang="en-US">:</span></p>
<p style="margin-bottom: 0cm">0: We Draw Only Where The Stencil Is
Not Equal to <i>mode</i></p>
<p style="margin-bottom: 0cm">1: We Draw Only Where The Stencil Is
Equal to <i>mode</i></p>
<p style="margin-bottom: 0cm">2: We Draw Only Where The Stencil Is
Smaller or Equal to <i>mode</i></p>
<p style="margin-bottom: 0cm">3: We Draw Only Where The Stencil Is
Greater or Equal to <i>mode</i></p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the stencil operation that will be
computer to decide whether to draw or not on a portion of the screen.</p>
<p style="margin-bottom: 0cm">A stencil buffer can be seen as a 2d
matrix, containing as many elements as the pixels on the screen: each
element is an integer number, that is set to zero, and can be
increased or decreased when a stencil mesh is rendered on it. The
stencil buffer is not visible, but affects the next rendering
operation, that will happen only on the allowed areas. The
command StencilMode allows to decide which comparison must be done to
decide if a certain pixel is allowed to be plot on, or not.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TerrainHeight"></a>
<b>float TerrainHeight (Terrain* terr, int x, int z)</b></p>
<p style="margin-bottom: 0cm">Returns the height of the terrain at
terrain grid coordinates <i>x</i>,<i>z</i>. The value returned is in
the range 0 to 1. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TerrainX"></a>
<b>float TerrainX (Terrain* terr, float x, float y, float z)</b></p>
<p style="margin-bottom: 0cm">Returns the interpolated x coordinate
on a terrain. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TerrainY"></a>
<b>float TerrainY (Terrain* terr, float x, float y, float z)</b></p>
<p style="margin-bottom: 0cm">Returns the interpolated y coordinate
on a terrain. 
</p>
<p style="margin-bottom: 0cm">Gets the ground's height, basically. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TerrainZ"></a>
<b>float TerrainZ (Terrain* terr, float x, float y, float z)</b></p>
<p style="margin-bottom: 0cm">Returns the interpolated z coordinate
on a terrain. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TexToBuffer"></a>
<b>void TexToBuffer(Texture* tex,unsigned char* buffer, int frame)</b></p>
<p style="margin-bottom: 0cm">Converts a texture to an image buffer.
The image buffer must be allocated in advance. The image buffer will
be in format RGBA (each pixel is represented by 4 bytes: red, green,
blue and alpha values), and it will have the same width and height of
the texture. The argument <i>tex </i><span style="font-style: normal">is
the texture handle, the argument </span><i>buffer</i><span style="font-style: normal">
is a pointer to the image buffer. </span>Argument <i>frame </i><span style="font-style: normal">is
currently unused. </span>
</p>
<p style="font-style: normal; margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureBlend"></a>
<b>void TextureBlend(Texture* tex,int blend)</b></p>
<p style="margin-bottom: 0cm"><i>Texture</i> - Texture handle.</p>
<p style="margin-bottom: 0cm"><i>Blend</i> - Blend mode of texture.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">0: Do not blend</p>
<p style="margin-bottom: 0cm">1: No blend or Alpha (alpha when
texture loaded with alpha flag - not recommended for multitexturing -
see below)</p>
<p style="margin-bottom: 0cm">2: Multiply (default)</p>
<p style="margin-bottom: 0cm">3: Add</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the blending mode for a texture.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">The texture blend mode determines how
the texture will blend with the texture or polygon which is 'below'
it. Texture 0 will blend with the polygons of the entity it is
applied to. Texture 1 will blend with texture 0. Texture 2 will blend
with texture 1. And so on.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><span lang="en-US">Texture blending in
</span><span lang="en-US">OpenB3D</span><span lang="en-US">
effectively takes the highest order texture (the one with the highest
index) and it blends with the texture below it, then that result to
the texture directly below again, and so on until texture 0 which is
blended with the polygons of the entity it is applied to and thus the
world, depending on the EntityBlend of the object.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Each of the blend modes are identical
to their EntityBlend counterparts.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">In the case of multitexturing (more
than one texture applied to an entity), it is not recommended you
blend textures that have been loaded with the alpha flag, as this can
cause unpredictable results on a variety of different graphics cards.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureCoords"></a>
<b>void TextureCoords(Texture* tex,int coords)</b></p>
<p style="margin-bottom: 0cm"><i>texture</i> - name of texture</p>
<p style="margin-bottom: 0cm"><i>coords</i> -</p>
<p style="margin-bottom: 0cm">0: UV coordinates are from first UV set
in vertices (default)</p>
<p style="margin-bottom: 0cm">1: UV coordinates are from second UV
set in vertices</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Sets the texture coordinate mode for a
texture.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This determines where the UV values
used to look up a texture come from. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureHeight"></a>
<b>int TextureHeight(Texture* tex)</b></p>
<p style="margin-bottom: 0cm">Returns the height of a texture. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureFilter"></a>
<b>void TextureFilter(char* match_text,int flags)</b></p>
<p style="margin-bottom: 0cm"><i>match_text</i> - text that, if found
in texture filename, will activate certain filters</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>flags</i> - filter texture flags:</p>
<p style="margin-bottom: 0cm">1: Color</p>
<p style="margin-bottom: 0cm">2: Alpha</p>
<p style="margin-bottom: 0cm">4: Masked</p>
<p style="margin-bottom: 0cm">8: Mipmapped</p>
<p style="margin-bottom: 0cm">16: Clamp U</p>
<p style="margin-bottom: 0cm">32: Clamp V</p>
<p style="margin-bottom: 0cm">64: Spherical reflection map</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Adds a texture filter. Any textures
loaded that contain the text specified by <i>match_text</i> will have
the provided flags added.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This is mostly of use when loading a
mesh.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureName"></a>
<b>const char* TextureName(Texture* tex)</b></p>
<p style="margin-bottom: 0cm">Returns a texture's filename. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TextureWidth"></a>
<b>int TextureWidth(Texture* tex)</b></p>
<p style="margin-bottom: 0cm">Returns the width of a texture. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormedX"></a>
<b>float TFormedX()</b></p>
<p style="margin-bottom: 0cm">Returns the X component of the last
<a href="#TFormPoint">TFormPoint</a>, <a href="#TFormVector">TFormVector</a>
or <a href="#TFormNormal">TFormNormal</a> operation. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormedY"></a>
<b>float TFormedY()</b></p>
<p style="margin-bottom: 0cm">Returns the Y component of the last
<a href="#TFormPoint">TFormPoint</a>, <a href="#TFormVector">TFormVector</a>
or <a href="#TFormNormal">TFormNormal</a> operation. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormedZ"></a>
<b>float TFormedZ()</b></p>
<p style="margin-bottom: 0cm">Returns the Z component of the last
<a href="#TFormPoint">TFormPoint</a>, <a href="#TFormVector">TFormVector</a>
or <a href="#TFormNormal">TFormNormal</a> operation. <br/>
<br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormNormal"></a>
<b>void TFormNormal(float x,float y,float z, Entity*
source_entity,Entity* dest_entity)</b></p>
<p style="margin-bottom: 0cm"><i>x</i>, <i>y</i>, <i>z</i> =
components of a vector in 3d space</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>source_entity</i> = handle of source
entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><i>dest_entity</i> = handle of
destination entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Transforms between coordinate systems.
After using TFormNormal the new</p>
<p style="margin-bottom: 0cm">components can be read with TFormedX(),
TFormedY() and TFormedZ().</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This is exactly the same as <a href="#TFormVector">TFormVector</a>
but with one added feature.</p>
<p style="margin-bottom: 0cm">After the transformation the new vector
is 'normalized', meaning it</p>
<p style="margin-bottom: 0cm">is scaled to have length 1.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">For example, suppose the result of
TFormVector is (1,2,2).</p>
<p style="margin-bottom: 0cm">This vector has length Sqr( 1*1 + 2*2 +
2*2 ) = Sqr( 9 ) = 3.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This means TFormNormal would produce (
1/3, 2/3, 2/3 ). 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormPoint"></a>
<b>void TFormPoint(float x,float y,float z, Entity*
source_entity,Entity* dest_entity)</b></p>
<p style="margin-bottom: 0cm"><i>x</i>, <i>y</i>, <i>z</i> =
coordinates of a point in 3d space</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>source_entity</i> = handle of source
entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><i>dest_entity</i> = handle of
destination entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Transforms between coordinate systems.
After using TFormPoint the new</p>
<p style="margin-bottom: 0cm">coordinates can be read with
TFormedX(), TFormedY() and TFormedZ().</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">See EntityX() for details about local
coordinates.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Consider a sphere built with
CreateSphere(). The 'north pole' is at (0,1,0).</p>
<p style="margin-bottom: 0cm">At first, local and global coordinates
are the same. As the sphere is moved,</p>
<p style="margin-bottom: 0cm">turned and scaled the global
coordinates of the point change.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">But it is always at (0,1,0) in the
sphere's local space. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TFormVector"></a>
<b>void TFormVector(float x,float y,float z, Entity*
source_entity,Entity* dest_entity)</b></p>
<p style="margin-bottom: 0cm"><i>x</i>, <i>y</i><span style="font-style: normal">,</span>
<i>z</i> = components of a vector in 3d space</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>source_entity</i> = handle of source
entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><i>dest_entity</i> = handle of
destination entity, or 0 for 3d world</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Transforms between coordinate systems.
After using TFormVector the new</p>
<p style="margin-bottom: 0cm">components can be read with TFormedX(),
TFormedY() and TFormedZ().</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">See EntityX() for details about local
coordinates.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Similar to TFormPoint, but operates on
a vector. A vector can be thought of</p>
<p style="margin-bottom: 0cm">as 'displacement relative to current
location'.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">For example, vector (1,2,3) means one
step to the right, two steps up</p>
<p style="margin-bottom: 0cm">and three steps forward.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">This is analogous to PositionEntity and
MoveEntity:</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">PositionEntity entity, x,y,z ; put
entity at point (x,y,z)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">MoveEntity entity, x,y,z ; add vector
(x,y,z) to current position 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TranslateEntity"></a>
<b>void TranslateEntity(Entity* ent,float x,float y,float z,bool
glob)</b></p>
<p style="margin-bottom: 0cm">Translates an entity relative to its
current position and not its orientation. <br/>
<br/>
What this means
is that an entity will move in a certain direction despite where it
may be facing. Imagine that you have a game character that you want
to make jump in the air at the same time as doing a triple
somersault. Translating the character by a positive y amount will
mean the character will always travel directly up in their air,
regardless of where it may be facing due to the somersault action. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TriangleVertex"></a>
<b>int TriangleVertex(Surface* surf,int tri_no,int corner)</b></p>
<p style="margin-bottom: 0cm"><i>surface</i> - surface handle</p>
<p style="margin-bottom: 0cm"><i>triangle_index</i> - triangle index</p>
<p style="margin-bottom: 0cm"><i>corner</i> - corner of triangle.
Should be 0, 1 or 2.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Returns the vertex of a triangle
corner.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="TriggerCloseTo"></a><span style="font-variant: small-caps"><b>Action*
TriggerCloseTo(Entity* ent, float </b></span><span style="font-variant: small-caps"><b>x</b></span><span style="font-variant: small-caps"><b>,
float </b></span><span style="font-variant: small-caps"><b>y</b></span><span style="font-variant: small-caps"><b>,
float </b></span><span style="font-variant: small-caps"><b>z</b></span><span style="font-variant: small-caps"><b>,
float </b></span><span style="font-variant: small-caps"><b>d</b></span><span style="font-variant: small-caps"><b>istance</b></span><span style="font-variant: small-caps"><b>)</b></span></p>
<p style="margin-bottom: 0cm">Creates a trigger that will activate
when the distance between the entity <i>ent</i> and the point
specified by the coordinates <i>x</i>, <i>y</i> and <i>z</i><span style="font-style: normal">
is smaller than </span><i>distance</i>. The check will happen each
time <a href="#UpdateWorld">UpdateWorld</a> is called. If the command
<a href="#AppendAction">AppendAction</a>, is used to append some
actions to the trigger, those actions will be executed as soon as the
condition of the trigger is met.</p>
<p style="margin-bottom: 0cm"><a name="TriggerCollision"></a><span style="font-variant: small-caps"><b>Action*
TriggerCollision(Entity* ent, </b></span><span style="font-variant: small-caps"><b>int
type</b></span><span style="font-variant: small-caps"><b>)</b></span></p>
<p style="margin-bottom: 0cm">Creates a trigger that will activate
when the a collision between the entity <i>ent</i> and an entity of
<i>type</i> happens (see <a href="#EntityType">EntityType</a>). The
collision must be enabled with <a href="#Collisions">Collisions</a>.
The check will happen each time <a href="#UpdateWorld">UpdateWorld</a>
is called. If the command <a href="#AppendAction">AppendAction</a>,
is used to append some actions to the trigger, those actions will be
executed as soon as the condition of the trigger is met.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><a name="TriggerDistance"></a><span style="font-variant: small-caps"><b>Action*
Trigger</b></span><span style="font-variant: small-caps"><b>Distance</b></span><span style="font-variant: small-caps"><b>(Entity*
ent, </b></span><span style="font-variant: small-caps"><b>Entity*
target</b></span><span style="font-variant: small-caps"><b>, float
</b></span><span style="font-variant: small-caps"><b>d</b></span><span style="font-variant: small-caps"><b>istance</b></span><span style="font-variant: small-caps"><b>)</b></span></p>
<p style="margin-bottom: 0cm">Creates a trigger that will activate
when the distance between the entity <i>ent</i> and the<span style="font-style: normal">
</span><span style="font-style: normal">entity </span><i>target</i><span style="font-style: normal">
is smaller than </span><i>distance</i>. The check will happen each
time <a href="#UpdateWorld">UpdateWorld</a> is called. If the command
<a href="#AppendAction">AppendAction</a>, is used to append some
actions to the trigger, those actions will be executed as soon as the
condition of the trigger is met.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="TurnEntity"></a>
<b>void TurnEntity(Entity* ent,float x,float y,float z,bool glob)</b></p>
<p style="margin-bottom: 0cm"><i>entity</i> - name of entity to be
rotated</p>
<p style="margin-bottom: 0cm"><i>pitch</i> - angle in degrees that
entity will be pitched</p>
<p style="margin-bottom: 0cm"><i>yaw</i> - angle in degrees that
entity will be yawed</p>
<p style="margin-bottom: 0cm"><i>roll</i> - angle in degrees that
entity will be rolled</p>
<p style="margin-bottom: 0cm"><i>global</i> (optional) -</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm">Turns an entity relative to its current
orientation.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Pitch</i> is the same as the x angle
of an entity, and is equivalent to tilting forward/backwards.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Yaw</i> is the same as the y angle
of an entity, and is equivalent to turning left/right.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><i>Roll</i> is the same as the z angle
of an entity, and is equivalent to tilting left/right.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">If <i>global</i> is 0 the rotation will
be relative to the entitys current rotation, otherwise fixed
rotation axis will be used.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UpdateNormals"></a>
<b>void UpdateNormals(Entity* ent)</b></p>
<p style="margin-bottom: 0cm">Recalculates all normals in a mesh,
terrain, or geosphere. In a mesh this is necessary for correct
lighting if you have not set surface normals using 'VertexNormals'
commands. In a geosphere or a terrain this is necessary after a
command like ModifyTerrain or ModifyGeosphere is used.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UpdateTexCoords"></a>
<b>void UpdateTexCoords(Surface* surf)</b></p>
<p style="margin-bottom: 0cm">Recalculates the second set of texture
coordinates, replacing them with 3d texture coordinates. These
coordinates will work only with 3d textures (loaded with
<a href="#LoadMaterial">LoadMaterial</a>)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UpdateWorld"></a>
<b>void UpdateWorld(float anim_speed)</b></p>
<p>Animates all entities in the world, and performs collision
checking. It also updates particles, actions, and constraints. 
</p>
<p>The optional <em>anim_speed!</em> parameter allows you affect the
animation speed of all entities at once. A value of 1 (default) will
animate entities at their usual animation speed, a value of 2 will
animate entities at double their animation speed, and so on. 
</p>
<p>For best results use this command once per main loop, just before
calling <a href="#RenderWorld">RenderWorld</a>. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseEntity"></a>
<b>void UseEntity(Shader* material, char* name, Entity* ent, int
mode)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns a matrix
</span><span lang="en-US">coming from a specific entity, </span><span lang="en-US">calculated
automatically by OpenB3D, to the vertex shader. </span><span lang="en-US">A
typical use is passing the matrix from a light entity.</span><span lang="en-US">
The parameter </span><span lang="en-US"><i>mode</i></span><span lang="en-US">
tells which matrix must be associated with </span><span lang="en-US"><i>name</i></span><span lang="en-US">:
</span>
</p>
<p style="margin-bottom: 0cm"><span lang="en-US">0: </span><span lang="en-US">matrix</span></p>
<p style="margin-bottom: 0cm">1: inverse matrix</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseFloat"></a>
<b>void UseFloat(Shader* material, char* name, float* v1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns a variable
of single precision to be used as a float parameter inside a shader,
where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseFloat2"></a>
<b>void UseFloat2(Shader* material, char* name, float* v1, float* v2)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">two</span><span lang="en-US">
variable</span><span lang="en-US">s</span><span lang="en-US"> of
single precision to be used as </span><span lang="en-US">elements of
a</span><span lang="en-US"> float </span><span lang="en-US">vector
</span><span lang="en-US">inside a shader, where it will be
accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseFloat3"></a>
<b>void UseFloat3(Shader* material, char* name, float* v1, float* v2,
float* v3)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">three
</span><span lang="en-US">variable</span><span lang="en-US">s</span><span lang="en-US">
of single precision to be used as </span><span lang="en-US">elements
of a</span><span lang="en-US"> float </span><span lang="en-US">vector
</span><span lang="en-US">inside a shader, where it will be
accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseFloat4"></a>
<b>void UseFloat4(Shader* material, char* name, float* v1, float* v2,
float* v3, float* v4)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">four
</span><span lang="en-US">variable</span><span lang="en-US">s</span><span lang="en-US">
of single precision to be used as </span><span lang="en-US">elements
of a</span><span lang="en-US"> float </span><span lang="en-US">vector
</span><span lang="en-US">inside a shader, where it will be
accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseInteger"></a>
<b>void UseInteger(Shader* material, char* name, int* v1)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns a</span><span lang="en-US">n
integer</span><span lang="en-US"> variable to be used as a float
parameter inside a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseInteger2"></a>
<b>void UseInteger2(Shader* material, char* name, int* v1, int* v2)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">two
integer </span><span lang="en-US">variable</span><span lang="en-US">s</span><span lang="en-US">
to be used as </span><span lang="en-US">elements of a</span><span lang="en-US">
float </span><span lang="en-US">vector </span><span lang="en-US">inside
a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseInteger3"></a>
<b>void UseInteger3(Shader* material, char* name, int* v1, int* v2,
int* v3)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">three
integer </span><span lang="en-US">variable</span><span lang="en-US">s</span><span lang="en-US">
to be used as </span><span lang="en-US">elements of a</span><span lang="en-US">
float </span><span lang="en-US">vector </span><span lang="en-US">inside
a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseInteger4"></a>
<b>void UseInteger4(Shader* material, char* name, int* v1, int* v2,
int* v3, int* v4)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns </span><span lang="en-US">four
integer </span><span lang="en-US">variable</span><span lang="en-US">s</span><span lang="en-US">
to be used as </span><span lang="en-US">elements of a</span><span lang="en-US">
float </span><span lang="en-US">vector </span><span lang="en-US">inside
a shader, where it will be accessible as </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
The value of the variable will be automatically passed to the shader
</span><span lang="en-US">each time the shader is used for rendering.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseMatrix"></a>
<b>void UseMatrix(Shader* material, char* name, int mode)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Assigns a matrix
calculated automatically by OpenB3D to the vertex shader. The
parameter </span><span lang="en-US"><i>mode</i></span><span lang="en-US">
tells which matrix must be associated with </span><span lang="en-US"><i>name</i></span><span lang="en-US">:
</span>
</p>
<p style="margin-bottom: 0cm">0: model matrix (based on the objects
position, scale and rotation)</p>
<p style="margin-bottom: 0cm">1: view matrix (based on the cameras
position and rotation)</p>
<p style="margin-bottom: 0cm">2: projection matrix (based on camera
zoom, used for perspective deformation)</p>
<p style="margin-bottom: 0cm">3: model-view matrix (1 and 2 combined)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseStencil"></a>
<b>void UseStencil(Stencil* stencil)</b></p>
<p style="margin-bottom: 0cm">Activates a stencil. A stencil affects
the next <a href="#RenderWorld">RenderWorld</a> operation (and in
general, any other opengl drawing operation), that wont happen
anymore on the whole drawable area, but only on part of it, as if a
physical stencil with holes in it were placed on the canvas, to
affect any painting attempts. Using 0 as argument will disable the
active stencil, returning to normal mode.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm">Stencils should not be used on a scene
that uses also shadows. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="UseSurface"></a>
<b>void UseSurface(Shader* material, char* name, Surface* surface,
int vbo)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Tells the shader to
bind the data from a surface to an attribute identified by </span><span lang="en-US"><i>name</i></span><span lang="en-US">.
</span><span lang="en-US">In current version, the parameter </span><span lang="en-US"><i>surface</i></span><span lang="en-US">
</span><span lang="en-US">has no meaning</span><span lang="en-US">,
the current surface that is being rendered will be used. The
parameter </span><span lang="en-US"><i>vbo</i></span><span lang="en-US">
states which array has to be passed:</span></p>
<p style="margin-bottom: 0cm">1: vertex coordinates</p>
<p style="margin-bottom: 0cm">2: texture mapping coordinates (first
set)</p>
<p style="margin-bottom: 0cm">3: texture mapping coordinates (second
set), or 3d texture mapping coordinates on a mesh where
UpdateTexCoords has been used</p>
<p style="margin-bottom: 0cm">4: vertex normals</p>
<p style="margin-bottom: 0cm">5: vertex color, in RGB format</p>
<p style="margin-bottom: 0cm">6: vertex color, in RGBA format (vec4,
including also alpha channel)</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VectorPitch"></a>
<b>float VectorPitch(float vx,float vy,float vz)</b></p>
<p style="margin-bottom: 0cm">Returns the pitch value of a vector.
<br/>
<br/>
Using this command will return the same result as using
<a href="#EntityPitch">EntityPitch</a> to get the pitch value of an
entity that is pointing in the vector's direction. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VectorYaw"></a>
<b>float VectorYaw(float vx,float vy,float vz)</b></p>
<p style="margin-bottom: 0cm">Returns the yaw value of a vector.
<br/>
<br/>
Using this command will return the same result as using
<a href="#EntityYaw">EntityYaw</a> to get the yaw value of an entity
that is pointing in the vector's direction. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexAlpha"></a>
<b>float VertexAlpha(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">Returns the alpha component of a
vertices color, set using <a href="#VertexColor">VertexColor</a></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexBlue"></a>
<b>float VertexBlue(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">Returns the blue component of a
vertices color. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexColor"></a>
<b>void VertexColor(Surface* surf,int vid,float r,float g,float
b,float a)</b></p>
<p style="margin-bottom: 0cm">Sets the color of an existing vertex.
<br/>
<br/>
NB. If you want to set the alpha individually for
vertices using the <i>alpha</i> parameter then you need to use
EntityFX 32 (to force alpha-blending) on the entity. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexCoords"></a>
<b>void VertexCoords(Surface* surf,int vid,float x,float y,float z)</b></p>
<p style="margin-bottom: 0cm">Sets the geometric coordinates of an
existing vertex. <br/>
<br/>
This is the command used to perform what
is commonly referred to as 'dynamic mesh deformation'. It will
reposition a vertex so that all the triangle edges connected to it,
will move also. This will give the effect of parts of the mesh
suddenly deforming. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexGreen"></a>
<b>float VertexGreen(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">green
</span><span lang="en-US">component of a vertices color. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexNormal"></a>
<b>void VertexNormal(Surface* surf,int vid,float nx,float ny,float
nz)</b></p>
<p style="margin-bottom: 0cm">Sets the normal of an existing vertex. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexNX"></a>
<b>float VertexNX(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">Returns the x component of a vertices
normal. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexNY"></a>
<b>float VertexNY(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">Returns the y component of a vertices
normal. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexNZ"></a>
<b>float VertexNZ(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">Returns the z component of a vertices
normal. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexRed"></a>
<b>float VertexRed(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Returns the </span><span lang="en-US">red
</span><span lang="en-US">component of a vertices color. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexTexCoords"></a>
<b>void VertexTexCoords(Surface* surf,int vid,float u,float v,float
w,int coord_set)</b></p>
<p style="margin-bottom: 0cm"><i>surface</i> - surface handle</p>
<p style="margin-bottom: 0cm"><i>index</i> - index of vertex</p>
<p style="margin-bottom: 0cm"><i>u</i> - u coordinate of vertex</p>
<p style="margin-bottom: 0cm"><i>v</i> - v coordinate of vertex</p>
<p style="margin-bottom: 0cm"><i>w</i> (optional) - w coordinate of
vertex. It is valid only in 3d texture mode</p>
<p style="margin-bottom: 0cm">coord_set (optional) - co_oord set.
Should be set to 0, 1 or 2.</p>
<p style="margin-bottom: 0cm"><b>Description</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">Sets the texture
coordinates of an existing vertex. </span><span lang="en-US">Use a
value of 2 for </span><span lang="en-US"><i>coord_set</i></span><span lang="en-US">
to specify that the coordinates are in 3d format (used only for 3d
textures, loaded with LoadMaterial). </span><span lang="en-US">Coordinates
in 3d format can be used only after using </span><a href="#UpdateTexCoords">UpdateTexCoords</a><span lang="en-US">
on the mesh.</span></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexU"></a>
<b>float VertexU(Surface* surf,int vid,int coord_set)</b></p>
<p style="margin-bottom: 0cm">Returns the texture u coordinate of a
vertex. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexV"></a>
<b>float VertexV(Surface* surf,int vid,int coord_set)</b></p>
<p style="margin-bottom: 0cm">Returns the texture v coordinate of a
vertex. <br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexW"></a>
<b>float VertexW(Surface* surf,int vid,int coord_set)</b></p>
<p style="margin-bottom: 0cm">Returns the texture w coordinate of a
vertex. It will usually return 0, since the coordinate system used by
default is 2d. If the command <a href="#UpdateTexCoords">UpdateTexCoords</a>
has been used on the mesh, and a value of 2 is used for <i>coord_set</i><span style="font-style: normal">,
the w coordinate is used too.</span><br/>
<br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexX"></a>
<b>float VertexX(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm">This function return the <strong>X</strong>
coordinate of a vertex. The vertex has to be specified with <em>index</em>
variable; every surface has its own vertices, so <em>surface</em>
handle must be specified, too. 
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexY"></a>
<b>float VertexY(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">This function return
the </span><strong><span lang="en-US"><b>Y</b></span></strong><span lang="en-US">
coordinate of a vertex. The vertex has to be specified with </span><em><span lang="en-US">index</span></em><span lang="en-US">
variable; every surface has its own vertices, so </span><em><span lang="en-US">surface</span></em><span lang="en-US">
handle must be specified, too. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VertexZ"></a>
<b>float VertexZ(Surface* surf,int vid)</b></p>
<p style="margin-bottom: 0cm"><span lang="en-US">This function return
the </span><strong><span lang="en-US"><b>Z</b></span></strong><span lang="en-US">
coordinate of a vertex. The vertex has to be specified with </span><em><span lang="en-US">index</span></em><span lang="en-US">
variable; every surface has its own vertices, so </span><em><span lang="en-US">surface</span></em><span lang="en-US">
handle must be specified, too. </span>
</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="VoxelSpriteMaterial"></a>
<b>void VoxelSpriteMaterial(VoxelSprite* voxelspr, Material* mat)</b></p>
<p style="margin-bottom: 0cm">Applies a 3d texture (loaded with
<a href="#LoadMaterial">LoadMaterial</a>) to a 3d sprite. The texture
will be rendered as a set of voxels, so the sprite will have a solid
look, that changes according to the observers direction.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="font-variant: small-caps; margin-bottom: 0cm"><a name="Wireframe"></a>
<b>void Wireframe(int enable)</b></p>
<p style="margin-bottom: 0cm">With <em>enable</em>=1, it set
wireframe mode (only outlines will be visible: it's useful for
debug); with <em>enable</em>=0 will set back normal mode</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
</body>
</html>